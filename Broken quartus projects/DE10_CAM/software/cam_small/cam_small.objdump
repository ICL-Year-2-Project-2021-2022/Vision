
cam_small.elf:     file format elf32-littlenios2
cam_small.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04020020

Program Header:
    LOAD off    0x00001000 vaddr 0x04020000 paddr 0x04020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04020020 paddr 0x04020020 align 2**12
         filesz 0x00003820 memsz 0x00003820 flags r-x
    LOAD off    0x00004840 vaddr 0x04023840 paddr 0x040239b8 align 2**12
         filesz 0x00000178 memsz 0x00000178 flags rw-
    LOAD off    0x00004b30 vaddr 0x04023b30 paddr 0x04023b30 align 2**12
         filesz 0x00000000 memsz 0x00000020 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04020000  04020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  04020020  04020020  000049b8  2**0
                  CONTENTS
  2 .text         00002b64  04020020  04020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000cbc  04022b84  04022b84  00003b84  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000178  04023840  040239b8  00004840  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000020  04023b30  04023b30  00004b30  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  00000000  00000000  000049b8  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  04023b50  04023b50  000049b8  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  000049b8  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000550  00000000  00000000  000049e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000a54f  00000000  00000000  00004f30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000320c  00000000  00000000  0000f47f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00003947  00000000  00000000  0001268b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000c54  00000000  00000000  00015fd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00001b69  00000000  00000000  00016c28  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00003567  00000000  00000000  00018791  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000060  00000000  00000000  0001bcf8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000348  00000000  00000000  0001bd58  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0001ddca  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000a  00000000  00000000  0001ddcd  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0001ddd7  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0001ddd8  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0001ddd9  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0001dddd  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0001dde1  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000009  00000000  00000000  0001dde5  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000009  00000000  00000000  0001ddee  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000009  00000000  00000000  0001ddf7  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000004  00000000  00000000  0001de00  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000026  00000000  00000000  0001de04  2**0
                  CONTENTS, READONLY
 30 .jdi          00004eb7  00000000  00000000  0001de2a  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     00097114  00000000  00000000  00022ce1  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04020000 l    d  .entry	00000000 .entry
04020020 l    d  .exceptions	00000000 .exceptions
04020020 l    d  .text	00000000 .text
04022b84 l    d  .rodata	00000000 .rodata
04023840 l    d  .rwdata	00000000 .rwdata
04023b30 l    d  .bss	00000000 .bss
00000000 l    d  .sdram	00000000 .sdram
04023b50 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../cam_small_bsp//obj/HAL/src/crt0.o
04020068 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 I2C_core.c
00000000 l    df *ABS*	00000000 auto_focus.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 mipi_bridge_config.c
04022fee l     O .rodata	00000034 MipiBridgeReg
00000000 l    df *ABS*	00000000 mipi_camera_config.c
040230c0 l     O .rodata	00000774 MipiCameraReg
00000000 l    df *ABS*	00000000 queue.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
04021ee0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
04023840 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
00000000 l    df *ABS*	00000000 alt_getchar.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0402398c l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
04022b30 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
04021dc4 g     F .text	0000001c putchar
04022824 g     F .text	0000002c alt_main
04021de0 g     F .text	00000080 _puts_r
04020958 g     F .text	00000074 Focus_Released
040201d8 g     F .text	00000048 ACK_check
040239b8 g       *ABS*	00000000 __flash_rwdata_start
04020184 g     F .text	00000054 ACK_single_check
040209cc g     F .text	00000144 Focus_Window
040211d0 g     F .text	00000038 OV8865_write_AF
04023b50 g       *ABS*	00000000 __alt_heap_start
040217ec g     F .text	00000038 QUEUE_IsFull
04021d70 g     F .text	0000004c printf
04020220 g     F .text	00000108 OC_I2C_Write
04020874 g     F .text	000000e4 Focus_Init
0402399c g     O .rwdata	00000004 jtag_uart
04022b44 g     F .text	00000008 altera_nios2_gen2_irq_init
04020000 g     F .entry	0000001c __reset
04020020 g       *ABS*	00000000 __flash_exceptions_start
0402397a g     O .rwdata	00000001 focus_scal
04023b38 g     O .bss	00000004 errno
04023b40 g     O .bss	00000004 alt_argv
0402b978 g       *ABS*	00000000 _gp
04022988 g     F .text	00000004 usleep
04023920 g     O .rwdata	00000030 alt_fd_list
04021dbc g     F .text	00000008 _putchar_r
040200a0 g     F .text	00000090 oc_i2c_init_ex
04021e60 g     F .text	00000014 puts
040217dc g     F .text	00000010 QUEUE_IsEmpty
04022a10 g     F .text	0000005c altera_avalon_jtag_uart_read
04021ab0 g     F .text	00000014 malloc
04021d34 g     F .text	0000003c _printf_r
04020000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
040219f4 g     F .text	00000064 .hidden __udivsi3
04022b4c g     F .text	00000038 alt_icache_flush
040218f0 g     F .text	0000000c QUEUE_Empty
0402124c g     F .text	00000088 OV8865_FOCUS_Move_to
0402188c g     F .text	00000064 QUEUE_Pop
04021e74 g     F .text	00000050 _sbrk_r
0402397c g     O .rwdata	00000002 focus_height
040239a0 g     O .rwdata	00000004 alt_max_fd
04021198 g     F .text	00000038 OV8865_write_cmos_sensor_8
04023984 g     O .rwdata	00000004 _global_impure_ptr
04023b50 g       *ABS*	00000000 __bss_end
04022700 g     F .text	00000044 alt_getchar
040228d0 g     F .text	000000b8 alt_tick
04023980 g     O .rwdata	00000002 video_h
04020b10 g     F .text	000000ac mipi_clear_error
040205b0 g     F .text	00000134 OC_I2CL_Write
0402289c g     F .text	00000034 alt_alarm_stop
04020328 g     F .text	00000034 ACK_judge_for_read
04021374 g     F .text	000000a0 OV8865SetGain
04023950 g     O .rwdata	00000028 alt_dev_null
0402006c g     F .text	00000018 Write32_Data
04022b18 g     F .text	00000018 alt_dcache_flush_all
04023979 g     O .rwdata	00000001 focus_scal_f
040239b8 g       *ABS*	00000000 __ram_rwdata_end
040239a4 g     O .rwdata	00000008 alt_dev_list
0402298c g     F .text	00000060 write
04022598 g     F .text	00000058 _putc_r
04023840 g       *ABS*	00000000 __ram_rodata_end
04021a58 g     F .text	00000058 .hidden __umodsi3
04020c50 g     F .text	00000130 mipi_show_error_info_more
04023b50 g       *ABS*	00000000 end
04040000 g       *ABS*	00000000 __alt_stack_pointer
04022a6c g     F .text	00000034 altera_avalon_jtag_uart_write
04021f4c g     F .text	00000524 ___vfprintf_internal_r
04021af8 g     F .text	000000e4 _free_r
04020020 g     F .text	0000004c _start
04023b4c g     O .bss	00000004 _alt_tick_rate
04021824 g     F .text	00000068 QUEUE_Push
04023b48 g     O .bss	00000004 _alt_nticks
04022a0c g     F .text	00000004 alt_sys_init
04021160 g     F .text	00000038 OV8865_read_cmos_sensor_8
04021034 g     F .text	00000038 MipiBridgeRegWrite
04023840 g       *ABS*	00000000 __ram_rwdata_start
04022b84 g       *ABS*	00000000 __ram_rodata_start
04022aa0 g     F .text	00000078 alt_busy_sleep
04023b50 g       *ABS*	00000000 __alt_stack_base
04020130 g     F .text	00000014 oc_i2c_init
04022850 g     F .text	0000004c sbrk
04021630 g     F .text	00000148 MipiCameraInit
04021020 g     F .text	00000014 nSWAP16
0402248c g     F .text	000000b8 __sfvwrite_small_dev
04021778 g     F .text	00000060 QUEUE_New
04023b30 g       *ABS*	00000000 __bss_start
04021ad8 g     F .text	00000020 memset
04020dfc g     F .text	00000224 main
04023b3c g     O .bss	00000004 alt_envp
04023998 g     O .rwdata	00000004 uart_0
04040000 g       *ABS*	00000000 __alt_heap_limit
04021bdc g     F .text	00000158 _malloc_r
040239b4 g     O .rwdata	00000004 alt_errno
04022544 g     F .text	00000054 putc
040218fc g     F .text	00000084 .hidden __divsi3
04020144 g     F .text	00000040 oc_i2c_uninit
040214a4 g     F .text	0000018c MIPI_BIN_LEVEL
04022b84 g       *ABS*	00000000 __flash_rodata_start
040229ec g     F .text	00000020 alt_irq_init
040210b0 g     F .text	000000b0 MipiBridgeInit
040225f0 g     F .text	00000058 _write_r
04023988 g     O .rwdata	00000004 _impure_ptr
04023b44 g     O .bss	00000004 alt_argc
0402106c g     F .text	00000044 MipiBridgeRegRead
04023982 g     O .rwdata	00000002 video_w
040239ac g     O .rwdata	00000008 alt_fs_list
04020084 g     F .text	0000001c Read32_Data
0402035c g     F .text	00000160 OC_I2C_Read
04020020 g       *ABS*	00000000 __ram_exceptions_start
040239b8 g       *ABS*	00000000 _edata
04023b50 g       *ABS*	00000000 _end
04021414 g     F .text	00000090 OV8865ReadExposure
04020020 g       *ABS*	00000000 __ram_exceptions_end
040204bc g     F .text	000000f4 OC_I2C_Read_Continue
04023978 g     O .rwdata	00000001 focus_th
04021980 g     F .text	00000074 .hidden __modsi3
04040000 g       *ABS*	00000000 __alt_data_end
00000000 g       *ABS*	00000000 __alt_mem_sdram
04020bbc g     F .text	00000094 mipi_show_error_info
040217d8 g     F .text	00000004 QUEUE_Delete
040206e4 g     F .text	00000190 OC_I2CL_Read
0402001c g       .entry	00000000 _exit
04021ec4 g     F .text	0000001c strlen
04023b30 g     O .bss	00000004 __malloc_sbrk_start
04022b38 g     F .text	0000000c alt_icache_flush_all
040212d4 g     F .text	000000a0 OV8865SetExposure
0402397e g     O .rwdata	00000002 focus_width
04023b34 g     O .bss	00000004 __malloc_free_list
04022470 g     F .text	0000001c __vfprintf_internal
04020d80 g     F .text	0000007c MIPI_Init
04022648 g     F .text	000000b8 fcntl
04023990 g     O .rwdata	00000008 alt_alarm_list
04021208 g     F .text	00000044 OV8865_read_AF
04022744 g     F .text	000000e0 alt_load
04021ac4 g     F .text	00000014 free



Disassembly of section .entry:

04020000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 4020000:	00810014 	movui	r2,1024
#endif

0:
    initi r2
 4020004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 4020008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 402000c:	00bffd16 	blt	zero,r2,4020004 <__alt_data_end+0xfffe0004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4020010:	004100b4 	movhi	at,1026
    ori r1, r1, %lo(_start)
 4020014:	08400814 	ori	at,at,32
    jmp r1
 4020018:	0800683a 	jmp	at

0402001c <_exit>:
 402001c:	00000000 	call	0 <__alt_mem_sdram>

Disassembly of section .text:

04020020 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 4020020:	00810014 	movui	r2,1024
#endif

0:
    initd 0(r2)
 4020024:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 4020028:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 402002c:	00bffd16 	blt	zero,r2,4020024 <__alt_data_end+0xfffe0024>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4020030:	06c10134 	movhi	sp,1028
    ori sp, sp, %lo(__alt_stack_pointer)
 4020034:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 4020038:	068100b4 	movhi	gp,1026
    ori gp, gp, %lo(_gp)
 402003c:	d6ae5e14 	ori	gp,gp,47480
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 4020040:	008100b4 	movhi	r2,1026
    ori r2, r2, %lo(__bss_start)
 4020044:	108ecc14 	ori	r2,r2,15152

    movhi r3, %hi(__bss_end)
 4020048:	00c100b4 	movhi	r3,1026
    ori r3, r3, %lo(__bss_end)
 402004c:	18ced414 	ori	r3,r3,15184

    beq r2, r3, 1f
 4020050:	10c00326 	beq	r2,r3,4020060 <_start+0x40>

0:
    stw zero, (r2)
 4020054:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 4020058:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 402005c:	10fffd36 	bltu	r2,r3,4020054 <__alt_data_end+0xfffe0054>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 4020060:	40227440 	call	4022744 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 4020064:	40228240 	call	4022824 <alt_main>

04020068 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 4020068:	003fff06 	br	4020068 <__alt_data_end+0xfffe0068>

0402006c <Write32_Data>:
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 402006c:	294b883a 	add	r5,r5,r5
 4020070:	294b883a 	add	r5,r5,r5
 4020074:	2909883a 	add	r4,r5,r4
 4020078:	21800035 	stwio	r6,0(r4)
    bPass=TRUE;
    return bPass;
}
 402007c:	00800044 	movi	r2,1
 4020080:	f800283a 	ret

04020084 <Read32_Data>:



bool  Read32_Data(alt_32 base_address, alt_32 offset_address, alt_32 *pData32){
	bool bPass;
	*pData32 =IORD(base_address ,offset_address  );
 4020084:	294b883a 	add	r5,r5,r5
 4020088:	294b883a 	add	r5,r5,r5
 402008c:	2909883a 	add	r4,r5,r4
 4020090:	20800037 	ldwio	r2,0(r4)
 4020094:	30800015 	stw	r2,0(r6)
	bPass=TRUE;
    return bPass;
}
 4020098:	00800044 	movi	r2,1
 402009c:	f800283a 	ret

040200a0 <oc_i2c_init_ex>:

	return bSuccess;
}

bool  oc_i2c_init_ex(alt_32 i2c_base, alt_32 ref_clk, alt_32 i2c_clk)
{
 40200a0:	defffe04 	addi	sp,sp,-8
 40200a4:	dc000015 	stw	r16,0(sp)
 40200a8:	2021883a 	mov	r16,r4
 40200ac:	2809883a 	mov	r4,r5
	const alt_u8 ControlValue = 0x80;

    // I2c sysclock =50M hz
	// i2c scl max 400k
	//scl =sysclock/(prescale*5)
	prescale = (ref_clk/(5*i2c_clk))-1;
 40200b0:	31400164 	muli	r5,r6,5

	return bSuccess;
}

bool  oc_i2c_init_ex(alt_32 i2c_base, alt_32 ref_clk, alt_32 i2c_clk)
{
 40200b4:	dfc00115 	stw	ra,4(sp)
	const alt_u8 ControlValue = 0x80;

    // I2c sysclock =50M hz
	// i2c scl max 400k
	//scl =sysclock/(prescale*5)
	prescale = (ref_clk/(5*i2c_clk))-1;
 40200b8:	40218fc0 	call	40218fc <__divsi3>
 40200bc:	10bfffc4 	addi	r2,r2,-1
 40200c0:	11c03fcc 	andi	r7,r2,255
	prescale_low = prescale & 0xFF;
	prescale_high = (prescale >> 8) & 0xFF;

   IOWR(i2c_base, 0, prescale_low);//write low byte of  prescale (reg 0)
 40200c4:	81c00035 	stwio	r7,0(r16)
 40200c8:	1005d23a 	srai	r2,r2,8
   IOWR(i2c_base, 1, prescale_high);//write high byte of prescale (reg 1)
 40200cc:	81800104 	addi	r6,r16,4
 40200d0:	10803fcc 	andi	r2,r2,255
 40200d4:	30800035 	stwio	r2,0(r6)

   //enable the I2C core, but disable the IRQ
   IOWR( i2c_base, 2, ControlValue);
 40200d8:	81400204 	addi	r5,r16,8
 40200dc:	01002004 	movi	r4,128
 40200e0:	29000035 	stwio	r4,0(r5)


    // check prescale low byte
    if (bSuccess){
    	read_data =IORD(i2c_base, 0);
 40200e4:	80c00037 	ldwio	r3,0(r16)
        if( (read_data & 0x00ff) != prescale_low ){
 40200e8:	18c03fcc 	andi	r3,r3,255
 40200ec:	38c0031e 	bne	r7,r3,40200fc <oc_i2c_init_ex+0x5c>
        }
    }

    // check prescale high byte
    if (bSuccess){
    	read_data =IORD(i2c_base, 1);
 40200f0:	30c00037 	ldwio	r3,0(r6)
        if( (read_data & 0x00ff) != prescale_high ){
 40200f4:	18c03fcc 	andi	r3,r3,255
 40200f8:	10c00526 	beq	r2,r3,4020110 <oc_i2c_init_ex+0x70>

   if (bSuccess){
//       printf("\nI2C core is enabled! \r\n");
   }
   else
       printf("\nI2C core is not enabled successfully! \r\n");
 40200fc:	010100b4 	movhi	r4,1026
 4020100:	210ae104 	addi	r4,r4,11140
 4020104:	4021e600 	call	4021e60 <puts>
 4020108:	0005883a 	mov	r2,zero
 402010c:	00000406 	br	4020120 <oc_i2c_init_ex+0x80>
        }
    }

    // check control
    if (bSuccess){
    	read_data =IORD(i2c_base, 2);
 4020110:	28800037 	ldwio	r2,0(r5)
        if( (read_data & 0x00ff) != ControlValue ){
 4020114:	10803fcc 	andi	r2,r2,255
 4020118:	113ff81e 	bne	r2,r4,40200fc <__alt_data_end+0xfffe00fc>
 402011c:	00800044 	movi	r2,1
   else
       printf("\nI2C core is not enabled successfully! \r\n");

   return bSuccess;

}
 4020120:	dfc00117 	ldw	ra,4(sp)
 4020124:	dc000017 	ldw	r16,0(sp)
 4020128:	dec00204 	addi	sp,sp,8
 402012c:	f800283a 	ret

04020130 <oc_i2c_init>:
bool oc_i2c_init(alt_32 i2c_base){
	bool bSuccess;
	const alt_32 ref_clk = 50*1000*1000; // 50MHz
	const alt_32 i2c_clk = 400*1000; // 400KHz

	bSuccess = oc_i2c_init_ex(i2c_base, ref_clk, i2c_clk);
 4020130:	018001b4 	movhi	r6,6
 4020134:	0140bef4 	movhi	r5,763
 4020138:	3186a004 	addi	r6,r6,6784
 402013c:	297c2004 	addi	r5,r5,-3968
 4020140:	40200a01 	jmpi	40200a0 <oc_i2c_init_ex>

04020144 <oc_i2c_uninit>:
{
	bool bSuccess=TRUE;
	alt_32 read_data;
	const alt_u8 ControlValue = 0x00;

    IOWR( i2c_base, 2, ControlValue);
 4020144:	21000204 	addi	r4,r4,8
 4020148:	20000035 	stwio	zero,0(r4)
   	read_data =IORD(i2c_base, 2);
 402014c:	20800037 	ldwio	r2,0(r4)
	if( (read_data & 0x00ff) != ControlValue ){
 4020150:	10803fcc 	andi	r2,r2,255
 4020154:	1000021e 	bne	r2,zero,4020160 <oc_i2c_uninit+0x1c>

}

bool oc_i2c_uninit(alt_32 i2c_base)
{
	bool bSuccess=TRUE;
 4020158:	00800044 	movi	r2,1
   else
       printf("\I2C core is failed to disable! \r\n");

   return bSuccess;

}
 402015c:	f800283a 	ret

   if (bSuccess){
//       printf("\I2C core  is disabled! \r\n");
   }
   else
       printf("\I2C core is failed to disable! \r\n");
 4020160:	010100b4 	movhi	r4,1026
   return bSuccess;

}

bool oc_i2c_uninit(alt_32 i2c_base)
{
 4020164:	deffff04 	addi	sp,sp,-4

   if (bSuccess){
//       printf("\I2C core  is disabled! \r\n");
   }
   else
       printf("\I2C core is failed to disable! \r\n");
 4020168:	210aec04 	addi	r4,r4,11184
   return bSuccess;

}

bool oc_i2c_uninit(alt_32 i2c_base)
{
 402016c:	dfc00015 	stw	ra,0(sp)

   if (bSuccess){
//       printf("\I2C core  is disabled! \r\n");
   }
   else
       printf("\I2C core is failed to disable! \r\n");
 4020170:	4021e600 	call	4021e60 <puts>
	const alt_u8 ControlValue = 0x00;

    IOWR( i2c_base, 2, ControlValue);
   	read_data =IORD(i2c_base, 2);
	if( (read_data & 0x00ff) != ControlValue ){
            bSuccess = FALSE;
 4020174:	0005883a 	mov	r2,zero
   else
       printf("\I2C core is failed to disable! \r\n");

   return bSuccess;

}
 4020178:	dfc00017 	ldw	ra,0(sp)
 402017c:	dec00104 	addi	sp,sp,4
 4020180:	f800283a 	ret

04020184 <ACK_single_check>:




bool  ACK_single_check(alt_32 i2c_base)
{
 4020184:	defffe04 	addi	sp,sp,-8
 4020188:	dc000015 	stw	r16,0(sp)
 402018c:	2021883a 	mov	r16,r4
	bool bSuccess=TRUE;
	alt_32 read_data;

    usleep(ACK_SLEEP_TIME);
 4020190:	01003e84 	movi	r4,250




bool  ACK_single_check(alt_32 i2c_base)
{
 4020194:	dfc00115 	stw	ra,4(sp)
	bool bSuccess=TRUE;
	alt_32 read_data;

    usleep(ACK_SLEEP_TIME);
    read_data =IORD(i2c_base, 4);
 4020198:	84000404 	addi	r16,r16,16
bool  ACK_single_check(alt_32 i2c_base)
{
	bool bSuccess=TRUE;
	alt_32 read_data;

    usleep(ACK_SLEEP_TIME);
 402019c:	40229880 	call	4022988 <usleep>
    read_data =IORD(i2c_base, 4);
 40201a0:	80800037 	ldwio	r2,0(r16)
    if(read_data & 0x02)
 40201a4:	1080008c 	andi	r2,r2,2
 40201a8:	10000226 	beq	r2,zero,40201b4 <ACK_single_check+0x30>
 40201ac:	0005883a 	mov	r2,zero
 40201b0:	00000506 	br	40201c8 <ACK_single_check+0x44>
            bSuccess = FALSE;
     if (bSuccess){
            usleep(ACK_SLEEP_TIME);
 40201b4:	01003e84 	movi	r4,250
 40201b8:	40229880 	call	4022988 <usleep>
            read_data =IORD(i2c_base, 4);
 40201bc:	80800037 	ldwio	r2,0(r16)
 40201c0:	1080200c 	andi	r2,r2,128
 40201c4:	1005003a 	cmpeq	r2,r2,zero
                if(read_data & 0x80)
                    bSuccess = FALSE;
     }
    return bSuccess;
}
 40201c8:	dfc00117 	ldw	ra,4(sp)
 40201cc:	dc000017 	ldw	r16,0(sp)
 40201d0:	dec00204 	addi	sp,sp,8
 40201d4:	f800283a 	ret

040201d8 <ACK_check>:


bool  ACK_check(alt_32 i2c_base){
 40201d8:	defffd04 	addi	sp,sp,-12
 40201dc:	dc400115 	stw	r17,4(sp)
 40201e0:	dc000015 	stw	r16,0(sp)
 40201e4:	dfc00215 	stw	ra,8(sp)
 40201e8:	2023883a 	mov	r17,r4
 40201ec:	040002c4 	movi	r16,11
 40201f0:	843fffc4 	addi	r16,r16,-1
    bool bSuccess = FALSE;
    int i=0;

    while(!bSuccess && i++ < 10){
 40201f4:	80000426 	beq	r16,zero,4020208 <ACK_check+0x30>
        bSuccess = ACK_single_check(i2c_base);
 40201f8:	8809883a 	mov	r4,r17
 40201fc:	40201840 	call	4020184 <ACK_single_check>

bool  ACK_check(alt_32 i2c_base){
    bool bSuccess = FALSE;
    int i=0;

    while(!bSuccess && i++ < 10){
 4020200:	103ffb26 	beq	r2,zero,40201f0 <__alt_data_end+0xfffe01f0>
 4020204:	00000106 	br	402020c <ACK_check+0x34>
 4020208:	0005883a 	mov	r2,zero
        bSuccess = ACK_single_check(i2c_base);
    }

    return bSuccess;
}
 402020c:	dfc00217 	ldw	ra,8(sp)
 4020210:	dc400117 	ldw	r17,4(sp)
 4020214:	dc000017 	ldw	r16,0(sp)
 4020218:	dec00304 	addi	sp,sp,12
 402021c:	f800283a 	ret

04020220 <OC_I2C_Write>:

bool  OC_I2C_Write(alt_32 i2c_base,alt_u8 device_address,alt_u8 sub_address, alt_u8 *pData, int nWriteLength)
{
 4020220:	defff804 	addi	sp,sp,-32
 4020224:	dd800615 	stw	r22,24(sp)
 4020228:	dd400515 	stw	r21,20(sp)
 402022c:	dcc00315 	stw	r19,12(sp)
 4020230:	dc400115 	stw	r17,4(sp)
 4020234:	dfc00715 	stw	ra,28(sp)
 4020238:	dd000415 	stw	r20,16(sp)
 402023c:	dc800215 	stw	r18,8(sp)
 4020240:	dc000015 	stw	r16,0(sp)
 4020244:	2027883a 	mov	r19,r4
 4020248:	3023883a 	mov	r17,r6
 402024c:	382d883a 	mov	r22,r7
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020250:	25400304 	addi	r21,r4,12
 4020254:	29403fcc 	andi	r5,r5,255
 4020258:	a9400035 	stwio	r5,0(r21)
 402025c:	24800404 	addi	r18,r4,16
 4020260:	00802404 	movi	r2,144
 4020264:	90800035 	stwio	r2,0(r18)
       printf("OC_I2C_Write error[1]\r\n");
       return FALSE;
   }

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 4020268:	40201d80 	call	40201d8 <ACK_check>
 402026c:	1000041e 	bne	r2,zero,4020280 <OC_I2C_Write+0x60>
        printf("OC_I2C_Write error[2]\r\n");
 4020270:	010100b4 	movhi	r4,1026
 4020274:	1021883a 	mov	r16,r2
 4020278:	210af504 	addi	r4,r4,11220
 402027c:	00001806 	br	40202e0 <OC_I2C_Write+0xc0>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020280:	8c403fcc 	andi	r17,r17,255
 4020284:	ac400035 	stwio	r17,0(r21)
 4020288:	05000404 	movi	r20,16
 402028c:	95000035 	stwio	r20,0(r18)
        printf("OC_I2C_Write error[4]\r\n");
        return FALSE;
    }

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 4020290:	9809883a 	mov	r4,r19
 4020294:	40201d80 	call	40201d8 <ACK_check>
 4020298:	1021883a 	mov	r16,r2
 402029c:	1000031e 	bne	r2,zero,40202ac <OC_I2C_Write+0x8c>
        printf("OC_I2C_Write error[5]\r\n");
 40202a0:	010100b4 	movhi	r4,1026
 40202a4:	210afb04 	addi	r4,r4,11244
 40202a8:	00000d06 	br	40202e0 <OC_I2C_Write+0xc0>
        return FALSE;
    }
 //  printf("\n receive ACK-reg address! \n");

#if 1
        for( i=nWriteLength-1;i>=0;i--){
 40202ac:	dc400817 	ldw	r17,32(sp)
 40202b0:	8c7fffc4 	addi	r17,r17,-1
 40202b4:	88000c16 	blt	r17,zero,40202e8 <OC_I2C_Write+0xc8>
        //set the txr reg data with the data
          if (!Write32_Data( i2c_base, 3,*(pData+i))){
 40202b8:	b445883a 	add	r2,r22,r17
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 40202bc:	10800003 	ldbu	r2,0(r2)
 40202c0:	a8800035 	stwio	r2,0(r21)
 40202c4:	95000035 	stwio	r20,0(r18)
             printf("OC_I2C_Write error[7]\r\n");
              return FALSE;
         }

         //wait TIP bit go to 0 to end Tx
          if(!ACK_check( i2c_base)){
 40202c8:	9809883a 	mov	r4,r19
 40202cc:	40201d80 	call	40201d8 <ACK_check>
 40202d0:	1021883a 	mov	r16,r2
 40202d4:	103ff61e 	bne	r2,zero,40202b0 <__alt_data_end+0xfffe02b0>
              printf("OC_I2C_Write error[8]\r\n");
 40202d8:	010100b4 	movhi	r4,1026
 40202dc:	210b0104 	addi	r4,r4,11268
 40202e0:	4021e600 	call	4021e60 <puts>
              return FALSE;
 40202e4:	00000506 	br	40202fc <OC_I2C_Write+0xdc>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 40202e8:	00801004 	movi	r2,64
 40202ec:	90800035 	stwio	r2,0(r18)
         printf("OC_I2C_Write error[9]\r\n");
         return FALSE;
     }
         //Sleep(10);
     //OS_msleep(1);
     usleep(SLEEP_TIME);
 40202f0:	01003e84 	movi	r4,250
 40202f4:	40229880 	call	4022988 <usleep>

  // printf("\n receive ACK-data! \n");

     return TRUE;
 40202f8:	04000044 	movi	r16,1

}
 40202fc:	8005883a 	mov	r2,r16
 4020300:	dfc00717 	ldw	ra,28(sp)
 4020304:	dd800617 	ldw	r22,24(sp)
 4020308:	dd400517 	ldw	r21,20(sp)
 402030c:	dd000417 	ldw	r20,16(sp)
 4020310:	dcc00317 	ldw	r19,12(sp)
 4020314:	dc800217 	ldw	r18,8(sp)
 4020318:	dc400117 	ldw	r17,4(sp)
 402031c:	dc000017 	ldw	r16,0(sp)
 4020320:	dec00804 	addi	sp,sp,32
 4020324:	f800283a 	ret

04020328 <ACK_judge_for_read>:


bool ACK_judge_for_read(alt_32 i2c_base)
{
 4020328:	defffe04 	addi	sp,sp,-8
 402032c:	dc000015 	stw	r16,0(sp)
 4020330:	2021883a 	mov	r16,r4
	bool bSuccess;
    alt_32 this_data;

   // OS_msleep( SLEEP_TIME );
     usleep(ACK_SLEEP_TIME);
 4020334:	01003e84 	movi	r4,250

}


bool ACK_judge_for_read(alt_32 i2c_base)
{
 4020338:	dfc00115 	stw	ra,4(sp)
	bool bSuccess;
    alt_32 this_data;

   // OS_msleep( SLEEP_TIME );
     usleep(ACK_SLEEP_TIME);
 402033c:	40229880 	call	4022988 <usleep>



bool  Read32_Data(alt_32 base_address, alt_32 offset_address, alt_32 *pData32){
	bool bPass;
	*pData32 =IORD(base_address ,offset_address  );
 4020340:	80800437 	ldwio	r2,16(r16)
        if(this_data & 0x02)
            bSuccess = FALSE;
    }
   //wait the rx ACK signal 0-valid

    return bSuccess;
 4020344:	1080008c 	andi	r2,r2,2

}
 4020348:	1005003a 	cmpeq	r2,r2,zero
 402034c:	dfc00117 	ldw	ra,4(sp)
 4020350:	dc000017 	ldw	r16,0(sp)
 4020354:	dec00204 	addi	sp,sp,8
 4020358:	f800283a 	ret

0402035c <OC_I2C_Read>:

bool  OC_I2C_Read(alt_32 i2c_base,alt_u8 device_address,alt_u8 sub_address, alt_u8 *pData8, int nReadLength){
 402035c:	defff604 	addi	sp,sp,-40
 4020360:	dd800615 	stw	r22,24(sp)
 4020364:	dd800a17 	ldw	r22,40(sp)
 4020368:	df000815 	stw	fp,32(sp)
 402036c:	dd400515 	stw	r21,20(sp)
 4020370:	dd000415 	stw	r20,16(sp)
 4020374:	dcc00315 	stw	r19,12(sp)
 4020378:	dc400115 	stw	r17,4(sp)
 402037c:	dfc00915 	stw	ra,36(sp)
 4020380:	ddc00715 	stw	r23,28(sp)
 4020384:	dc800215 	stw	r18,8(sp)
 4020388:	dc000015 	stw	r16,0(sp)
 402038c:	2029883a 	mov	r20,r4
 4020390:	2823883a 	mov	r17,r5
 4020394:	3039883a 	mov	fp,r6
 4020398:	3827883a 	mov	r19,r7
    //BYTE data = 0x0;
    alt_32 Data32;
    int i;

   //set the tx reg audio chip dev address with write bit
   IOWR( i2c_base, 3,device_address);
 402039c:	25400304 	addi	r21,r4,12
 40203a0:	28803fcc 	andi	r2,r5,255
 40203a4:	a8800035 	stwio	r2,0(r21)
   //set STA and WR bits(bit7 and bit4)
   IOWR( i2c_base, 4,0x90);
 40203a8:	24800404 	addi	r18,r4,16
 40203ac:	05c02404 	movi	r23,144
 40203b0:	95c00035 	stwio	r23,0(r18)
   //wait TIP bit go to 0 to end Tx
   if (!ACK_check( i2c_base)){
 40203b4:	40201d80 	call	40201d8 <ACK_check>
 40203b8:	1000041e 	bne	r2,zero,40203cc <OC_I2C_Read+0x70>
       printf("OC_I2C_Read error[2]\r\n");
 40203bc:	010100b4 	movhi	r4,1026
 40203c0:	1021883a 	mov	r16,r2
 40203c4:	210b0704 	addi	r4,r4,11292
 40203c8:	00000a06 	br	40203f4 <OC_I2C_Read+0x98>
       return FALSE;
   }
   IOWR(i2c_base, 3,sub_address);
 40203cc:	e7003fcc 	andi	fp,fp,255
 40203d0:	af000035 	stwio	fp,0(r21)

   //set WR bits(bit4)
   IOWR( i2c_base, 4,0x10);
 40203d4:	00800404 	movi	r2,16
 40203d8:	90800035 	stwio	r2,0(r18)
   //wait TIP bit go to 0 to end Tx
    if (!ACK_check( i2c_base)){
 40203dc:	a009883a 	mov	r4,r20
 40203e0:	40201d80 	call	40201d8 <ACK_check>
 40203e4:	1021883a 	mov	r16,r2
 40203e8:	1000041e 	bne	r2,zero,40203fc <OC_I2C_Read+0xa0>
        printf("OC_I2C_Read error[5]\r\n");
 40203ec:	010100b4 	movhi	r4,1026
 40203f0:	210b0d04 	addi	r4,r4,11316
 40203f4:	4021e600 	call	4021e60 <puts>
        return FALSE;
 40203f8:	00002306 	br	4020488 <OC_I2C_Read+0x12c>
  // printf("\n read receive ACK-reg address! \n");

   //read
    //set the tx reg audio chip dev address with read bit 1

    IOWR(i2c_base, 3,device_address|0x01);
 40203fc:	8c400054 	ori	r17,r17,1
 4020400:	8c403fcc 	andi	r17,r17,255
 4020404:	ac400035 	stwio	r17,0(r21)

   //set STA and WR bits(bit7 and bit4)
    IOWR( i2c_base, 4,0x90);
 4020408:	95c00035 	stwio	r23,0(r18)

   //wait TIP bit go to 0 to end Tx
    if (!ACK_check( i2c_base)){
 402040c:	a009883a 	mov	r4,r20
 4020410:	40201d80 	call	40201d8 <ACK_check>
 4020414:	1021883a 	mov	r16,r2
 4020418:	10000226 	beq	r2,zero,4020424 <OC_I2C_Read+0xc8>
 402041c:	0023883a 	mov	r17,zero
 4020420:	00000606 	br	402043c <OC_I2C_Read+0xe0>
        printf("OC_I2C_Read error[8]\r\n");
 4020424:	010100b4 	movhi	r4,1026
 4020428:	210b1304 	addi	r4,r4,11340
 402042c:	003ff106 	br	40203f4 <__alt_data_end+0xfffe03f4>
            printf("OC_I2C_Read error[10]\r\n");
            return FALSE;
        }
   // printf("\n read receive ACK-device address(read)! \n");

        Data32=IORD( i2c_base, 3);
 4020430:	a8800037 	ldwio	r2,0(r21)
        *(pData8+i) =  Data32 & 0xff;
 4020434:	98800005 	stb	r2,0(r19)
 4020438:	9cc00044 	addi	r19,r19,1
    if (!ACK_check( i2c_base)){
        printf("OC_I2C_Read error[8]\r\n");
        return FALSE;
    }

    for(i=0;i<nReadLength;i++){
 402043c:	8d800d0e 	bge	r17,r22,4020474 <OC_I2C_Read+0x118>
  // printf("\n read receive ACK-device address(read)! \n");
   //set the RD and ACK bit(bit5 and bit3)
    	IOWR( i2c_base, 4,((i+1) == nReadLength)?0x28:0x20);
 4020440:	8c400044 	addi	r17,r17,1
 4020444:	b4400226 	beq	r22,r17,4020450 <OC_I2C_Read+0xf4>
 4020448:	00800804 	movi	r2,32
 402044c:	00000106 	br	4020454 <OC_I2C_Read+0xf8>
 4020450:	00800a04 	movi	r2,40
 4020454:	90800035 	stwio	r2,0(r18)

        if (!ACK_judge_for_read( i2c_base)){
 4020458:	a009883a 	mov	r4,r20
 402045c:	40203280 	call	4020328 <ACK_judge_for_read>
 4020460:	1021883a 	mov	r16,r2
 4020464:	103ff21e 	bne	r2,zero,4020430 <__alt_data_end+0xfffe0430>
            printf("OC_I2C_Read error[10]\r\n");
 4020468:	010100b4 	movhi	r4,1026
 402046c:	210b1904 	addi	r4,r4,11364
 4020470:	003fe006 	br	40203f4 <__alt_data_end+0xfffe03f4>

        Data32=IORD( i2c_base, 3);
        *(pData8+i) =  Data32 & 0xff;
    }

    IOWR( i2c_base, 4,0x40);
 4020474:	00801004 	movi	r2,64
 4020478:	90800035 	stwio	r2,0(r18)

  // Sleep(10);
   //OS_msleep(1);
    usleep(SLEEP_TIME);
 402047c:	01003e84 	movi	r4,250
 4020480:	40229880 	call	4022988 <usleep>
 //  printf(" Read  [%02X] = %02Xh\r\n", sub_address, data);


   return TRUE;
 4020484:	04000044 	movi	r16,1

}
 4020488:	8005883a 	mov	r2,r16
 402048c:	dfc00917 	ldw	ra,36(sp)
 4020490:	df000817 	ldw	fp,32(sp)
 4020494:	ddc00717 	ldw	r23,28(sp)
 4020498:	dd800617 	ldw	r22,24(sp)
 402049c:	dd400517 	ldw	r21,20(sp)
 40204a0:	dd000417 	ldw	r20,16(sp)
 40204a4:	dcc00317 	ldw	r19,12(sp)
 40204a8:	dc800217 	ldw	r18,8(sp)
 40204ac:	dc400117 	ldw	r17,4(sp)
 40204b0:	dc000017 	ldw	r16,0(sp)
 40204b4:	dec00a04 	addi	sp,sp,40
 40204b8:	f800283a 	ret

040204bc <OC_I2C_Read_Continue>:


bool  OC_I2C_Read_Continue(alt_32 i2c_base,alt_u8 device_address, alt_u8 *pData8, int nReadLength){
 40204bc:	defff804 	addi	sp,sp,-32
	int i;
	alt_u32 Data32;

    IOWR(i2c_base, 3,device_address|0x01);
 40204c0:	29400054 	ori	r5,r5,1
   return TRUE;

}


bool  OC_I2C_Read_Continue(alt_32 i2c_base,alt_u8 device_address, alt_u8 *pData8, int nReadLength){
 40204c4:	dd800615 	stw	r22,24(sp)
 40204c8:	dd400515 	stw	r21,20(sp)
 40204cc:	dd000415 	stw	r20,16(sp)
 40204d0:	dc400115 	stw	r17,4(sp)
 40204d4:	dfc00715 	stw	ra,28(sp)
 40204d8:	dcc00315 	stw	r19,12(sp)
 40204dc:	dc800215 	stw	r18,8(sp)
 40204e0:	dc000015 	stw	r16,0(sp)
 40204e4:	2029883a 	mov	r20,r4
 40204e8:	3023883a 	mov	r17,r6
 40204ec:	382d883a 	mov	r22,r7
	int i;
	alt_u32 Data32;

    IOWR(i2c_base, 3,device_address|0x01);
 40204f0:	25400304 	addi	r21,r4,12
 40204f4:	29403fcc 	andi	r5,r5,255
 40204f8:	a9400035 	stwio	r5,0(r21)

   //set STA and WR bits(bit7 and bit4)
    IOWR( i2c_base, 4,0x90);
 40204fc:	24c00404 	addi	r19,r4,16
 4020500:	00802404 	movi	r2,144
 4020504:	98800035 	stwio	r2,0(r19)
//usleep(5*1000);
   //wait TIP bit go to 0 to end Tx
    if (!ACK_check( i2c_base)){
 4020508:	40201d80 	call	40201d8 <ACK_check>
 402050c:	10000226 	beq	r2,zero,4020518 <OC_I2C_Read_Continue+0x5c>
 4020510:	0025883a 	mov	r18,zero
 4020514:	00000706 	br	4020534 <OC_I2C_Read_Continue+0x78>
        printf("OC_I2C_Read error[8]\r\n");
 4020518:	010100b4 	movhi	r4,1026
 402051c:	1021883a 	mov	r16,r2
 4020520:	210b1304 	addi	r4,r4,11340
 4020524:	00000e06 	br	4020560 <OC_I2C_Read_Continue+0xa4>
            printf("OC_I2C_Read error[10]\r\n");
            return FALSE;
        }
   // printf("\n read receive ACK-device address(read)! \n");

        Data32=IORD( i2c_base, 3);
 4020528:	a8800037 	ldwio	r2,0(r21)
        *(pData8+i) =  Data32 & 0xff;
 402052c:	88800005 	stb	r2,0(r17)
 4020530:	8c400044 	addi	r17,r17,1
    if (!ACK_check( i2c_base)){
        printf("OC_I2C_Read error[8]\r\n");
        return FALSE;
    }

    for(i=0;i<nReadLength;i++){
 4020534:	95800e0e 	bge	r18,r22,4020570 <OC_I2C_Read_Continue+0xb4>
  // printf("\n read receive ACK-device address(read)! \n");
   //set the RD and ACK bit(bit5 and bit3)
    	IOWR( i2c_base, 4,((i+1) == nReadLength)?0x28:0x20);
 4020538:	94800044 	addi	r18,r18,1
 402053c:	b4800a26 	beq	r22,r18,4020568 <OC_I2C_Read_Continue+0xac>
 4020540:	00800804 	movi	r2,32
 4020544:	98800035 	stwio	r2,0(r19)

        if (!ACK_judge_for_read( i2c_base)){
 4020548:	a009883a 	mov	r4,r20
 402054c:	40203280 	call	4020328 <ACK_judge_for_read>
 4020550:	1021883a 	mov	r16,r2
 4020554:	103ff41e 	bne	r2,zero,4020528 <__alt_data_end+0xfffe0528>
            printf("OC_I2C_Read error[10]\r\n");
 4020558:	010100b4 	movhi	r4,1026
 402055c:	210b1904 	addi	r4,r4,11364
 4020560:	4021e600 	call	4021e60 <puts>
            return FALSE;
 4020564:	00000706 	br	4020584 <OC_I2C_Read_Continue+0xc8>
    }

    for(i=0;i<nReadLength;i++){
  // printf("\n read receive ACK-device address(read)! \n");
   //set the RD and ACK bit(bit5 and bit3)
    	IOWR( i2c_base, 4,((i+1) == nReadLength)?0x28:0x20);
 4020568:	00800a04 	movi	r2,40
 402056c:	003ff506 	br	4020544 <__alt_data_end+0xfffe0544>

        Data32=IORD( i2c_base, 3);
        *(pData8+i) =  Data32 & 0xff;
    }

    IOWR( i2c_base, 4,0x40);
 4020570:	00801004 	movi	r2,64
 4020574:	98800035 	stwio	r2,0(r19)

  // Sleep(10);
   //OS_msleep(1);
    usleep(SLEEP_TIME);
 4020578:	01003e84 	movi	r4,250
 402057c:	40229880 	call	4022988 <usleep>
 //  printf(" Read  [%02X] = %02Xh\r\n", sub_address, data);


   return TRUE;
 4020580:	04000044 	movi	r16,1

}
 4020584:	8005883a 	mov	r2,r16
 4020588:	dfc00717 	ldw	ra,28(sp)
 402058c:	dd800617 	ldw	r22,24(sp)
 4020590:	dd400517 	ldw	r21,20(sp)
 4020594:	dd000417 	ldw	r20,16(sp)
 4020598:	dcc00317 	ldw	r19,12(sp)
 402059c:	dc800217 	ldw	r18,8(sp)
 40205a0:	dc400117 	ldw	r17,4(sp)
 40205a4:	dc000017 	ldw	r16,0(sp)
 40205a8:	dec00804 	addi	sp,sp,32
 40205ac:	f800283a 	ret

040205b0 <OC_I2CL_Write>:


//  size > 2Kb
bool  OC_I2CL_Write(alt_32 i2c_base,alt_u8 device_address,alt_u16 sub_address,alt_u8 *pData, int nWriteLength)
    {
 40205b0:	defff804 	addi	sp,sp,-32
 40205b4:	dd800615 	stw	r22,24(sp)
 40205b8:	dd400515 	stw	r21,20(sp)
 40205bc:	dcc00315 	stw	r19,12(sp)
 40205c0:	dc400115 	stw	r17,4(sp)
 40205c4:	dfc00715 	stw	ra,28(sp)
 40205c8:	dd000415 	stw	r20,16(sp)
 40205cc:	dc800215 	stw	r18,8(sp)
 40205d0:	dc000015 	stw	r16,0(sp)
 40205d4:	2027883a 	mov	r19,r4
 40205d8:	3023883a 	mov	r17,r6
 40205dc:	382d883a 	mov	r22,r7
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 40205e0:	25400304 	addi	r21,r4,12
 40205e4:	29403fcc 	andi	r5,r5,255
 40205e8:	a9400035 	stwio	r5,0(r21)
 40205ec:	24800404 	addi	r18,r4,16
 40205f0:	00802404 	movi	r2,144
 40205f4:	90800035 	stwio	r2,0(r18)
   //set STA and WR bits(bit7 and bit4)
   if (!Write32_Data( i2c_base, 4,0x90))//0x90
       return FALSE;

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 40205f8:	40201d80 	call	40201d8 <ACK_check>
 40205fc:	1000041e 	bne	r2,zero,4020610 <OC_I2CL_Write+0x60>
        printf("OC_I2CL_Write error[0]\r\n");
 4020600:	010100b4 	movhi	r4,1026
 4020604:	1021883a 	mov	r16,r2
 4020608:	210b1f04 	addi	r4,r4,11388
 402060c:	00001506 	br	4020664 <OC_I2CL_Write+0xb4>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020610:	88bfffcc 	andi	r2,r17,65535
 4020614:	1004d23a 	srli	r2,r2,8
 4020618:	a8800035 	stwio	r2,0(r21)
 402061c:	05000404 	movi	r20,16
 4020620:	95000035 	stwio	r20,0(r18)
   //set WR bits(bit4)
    if (!Write32_Data( i2c_base, 4,0x10))
        return FALSE;

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 4020624:	9809883a 	mov	r4,r19
 4020628:	40201d80 	call	40201d8 <ACK_check>
 402062c:	1021883a 	mov	r16,r2
 4020630:	1000031e 	bne	r2,zero,4020640 <OC_I2CL_Write+0x90>
        printf("OC_I2CL_Write error[1]\r\n");
 4020634:	010100b4 	movhi	r4,1026
 4020638:	210b2504 	addi	r4,r4,11412
 402063c:	00000906 	br	4020664 <OC_I2CL_Write+0xb4>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020640:	8c403fcc 	andi	r17,r17,255
 4020644:	ac400035 	stwio	r17,0(r21)
 4020648:	95000035 	stwio	r20,0(r18)

   //set WR bits(bit4)
    Write32_Data( i2c_base, 4,0x10);

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 402064c:	9809883a 	mov	r4,r19
 4020650:	40201d80 	call	40201d8 <ACK_check>
 4020654:	1021883a 	mov	r16,r2
 4020658:	1000041e 	bne	r2,zero,402066c <OC_I2CL_Write+0xbc>
        printf("OC_I2CL_Write error[2]\r\n");
 402065c:	010100b4 	movhi	r4,1026
 4020660:	210b2b04 	addi	r4,r4,11436
 4020664:	4021e600 	call	4021e60 <puts>
        return FALSE;
 4020668:	00001306 	br	40206b8 <OC_I2CL_Write+0x108>
    }
  //  printf("\n receive ACK-reg low address! \n");

#if 1
    for( i=nWriteLength-1;i>=0;i--){
 402066c:	dc400817 	ldw	r17,32(sp)
 4020670:	8c7fffc4 	addi	r17,r17,-1
 4020674:	88000b16 	blt	r17,zero,40206a4 <OC_I2CL_Write+0xf4>
        //set the txr reg data with the other data 8 bit LSB
        if (!Write32_Data( i2c_base, 3,*(pData+i)))
 4020678:	b445883a 	add	r2,r22,r17
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 402067c:	10800003 	ldbu	r2,0(r2)
 4020680:	a8800035 	stwio	r2,0(r21)
 4020684:	95000035 	stwio	r20,0(r18)
       //set STO and WR bits(bit7 and bit4)
        if (!Write32_Data( i2c_base, 4,0x10))
            return FALSE;

        //wait TIP bit go to 0 to end Tx
         if(!ACK_check( i2c_base)){
 4020688:	9809883a 	mov	r4,r19
 402068c:	40201d80 	call	40201d8 <ACK_check>
 4020690:	1021883a 	mov	r16,r2
 4020694:	103ff61e 	bne	r2,zero,4020670 <__alt_data_end+0xfffe0670>
             printf("OC_I2CL_Write error[3]\r\n");
 4020698:	010100b4 	movhi	r4,1026
 402069c:	210b3104 	addi	r4,r4,11460
 40206a0:	003ff006 	br	4020664 <__alt_data_end+0xfffe0664>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 40206a4:	00801004 	movi	r2,64
 40206a8:	90800035 	stwio	r2,0(r18)
#endif
    if (!Write32_Data( i2c_base, 4,0x40))
         return FALSE;

     //OS_msleep(1);
      usleep(SLEEP_TIME);
 40206ac:	01003e84 	movi	r4,250
 40206b0:	40229880 	call	4022988 <usleep>
  //  printf("\n receive ACK-data! \n");

     return TRUE;
 40206b4:	04000044 	movi	r16,1
}
 40206b8:	8005883a 	mov	r2,r16
 40206bc:	dfc00717 	ldw	ra,28(sp)
 40206c0:	dd800617 	ldw	r22,24(sp)
 40206c4:	dd400517 	ldw	r21,20(sp)
 40206c8:	dd000417 	ldw	r20,16(sp)
 40206cc:	dcc00317 	ldw	r19,12(sp)
 40206d0:	dc800217 	ldw	r18,8(sp)
 40206d4:	dc400117 	ldw	r17,4(sp)
 40206d8:	dc000017 	ldw	r16,0(sp)
 40206dc:	dec00804 	addi	sp,sp,32
 40206e0:	f800283a 	ret

040206e4 <OC_I2CL_Read>:

   return TRUE;

} */

bool  OC_I2CL_Read(alt_32 i2c_base,alt_u8 device_address, alt_u16 sub_address, alt_u8 *pData8, int nReadLength){
 40206e4:	defff604 	addi	sp,sp,-40
 40206e8:	df000815 	stw	fp,32(sp)
 40206ec:	dd400515 	stw	r21,20(sp)
 40206f0:	dd000415 	stw	r20,16(sp)
 40206f4:	dcc00315 	stw	r19,12(sp)
 40206f8:	dc800215 	stw	r18,8(sp)
 40206fc:	dfc00915 	stw	ra,36(sp)
 4020700:	ddc00715 	stw	r23,28(sp)
 4020704:	dd800615 	stw	r22,24(sp)
 4020708:	dc400115 	stw	r17,4(sp)
 402070c:	dc000015 	stw	r16,0(sp)
 4020710:	2025883a 	mov	r18,r4
 4020714:	2827883a 	mov	r19,r5
 4020718:	3039883a 	mov	fp,r6
 402071c:	382b883a 	mov	r21,r7
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020720:	25000304 	addi	r20,r4,12
 4020724:	28803fcc 	andi	r2,r5,255
 4020728:	a0800035 	stwio	r2,0(r20)
 402072c:	24400404 	addi	r17,r4,16
 4020730:	05c02404 	movi	r23,144
 4020734:	8dc00035 	stwio	r23,0(r17)
   //set STA and WR bits(bit7 and bit4)
   if (!Write32_Data( i2c_base, 4,0x90))
       return FALSE;

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 4020738:	40201d80 	call	40201d8 <ACK_check>
 402073c:	1000041e 	bne	r2,zero,4020750 <OC_I2CL_Read+0x6c>
        printf("OC_I2CL_Read error[0]\r\n");
 4020740:	010100b4 	movhi	r4,1026
 4020744:	1021883a 	mov	r16,r2
 4020748:	210b3704 	addi	r4,r4,11484
 402074c:	00002206 	br	40207d8 <OC_I2CL_Read+0xf4>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020750:	e0bfffcc 	andi	r2,fp,65535
 4020754:	1004d23a 	srli	r2,r2,8
 4020758:	a0800035 	stwio	r2,0(r20)
 402075c:	05800404 	movi	r22,16
 4020760:	8d800035 	stwio	r22,0(r17)
   //set WR bits(bit4)
    if (!Write32_Data( i2c_base, 4,0x10))
        return FALSE;

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 4020764:	9009883a 	mov	r4,r18
 4020768:	40201d80 	call	40201d8 <ACK_check>
 402076c:	1021883a 	mov	r16,r2
 4020770:	1000031e 	bne	r2,zero,4020780 <OC_I2CL_Read+0x9c>
        printf("OC_I2CL_Read error[1]\r\n");
 4020774:	010100b4 	movhi	r4,1026
 4020778:	210b3d04 	addi	r4,r4,11508
 402077c:	00001606 	br	40207d8 <OC_I2CL_Read+0xf4>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 4020780:	e7003fcc 	andi	fp,fp,255
 4020784:	a7000035 	stwio	fp,0(r20)
 4020788:	8d800035 	stwio	r22,0(r17)
   //set WR bits(bit4)
    if (!Write32_Data( i2c_base, 4,0x10))
        return FALSE;

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 402078c:	9009883a 	mov	r4,r18
 4020790:	40201d80 	call	40201d8 <ACK_check>
 4020794:	1021883a 	mov	r16,r2
 4020798:	1000031e 	bne	r2,zero,40207a8 <OC_I2CL_Read+0xc4>
        printf("OC_I2CL_Read error[2]\r\n");
 402079c:	010100b4 	movhi	r4,1026
 40207a0:	210b4304 	addi	r4,r4,11532
 40207a4:	00000c06 	br	40207d8 <OC_I2CL_Read+0xf4>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 40207a8:	9cc00054 	ori	r19,r19,1
 40207ac:	9cc03fcc 	andi	r19,r19,255
 40207b0:	a4c00035 	stwio	r19,0(r20)
 40207b4:	8dc00035 	stwio	r23,0(r17)
   //set STA and WR bits(bit7 and bit4)
     if (!Write32_Data( i2c_base, 4,0x90))
         return FALSE;

   //wait TIP bit go to 0 to end Tx
    if(!ACK_check( i2c_base)){
 40207b8:	9009883a 	mov	r4,r18
 40207bc:	40201d80 	call	40201d8 <ACK_check>
 40207c0:	1021883a 	mov	r16,r2
 40207c4:	10000226 	beq	r2,zero,40207d0 <OC_I2CL_Read+0xec>
 40207c8:	0027883a 	mov	r19,zero
 40207cc:	00000706 	br	40207ec <OC_I2CL_Read+0x108>
        printf("OC_I2CL_Read error[3]\r\n");
 40207d0:	010100b4 	movhi	r4,1026
 40207d4:	210b4904 	addi	r4,r4,11556
 40207d8:	4021e600 	call	4021e60 <puts>
        return FALSE;
 40207dc:	00001806 	br	4020840 <OC_I2CL_Read+0x15c>
            printf("OC_I2CL_Read error[4]\r\n");
            return FALSE;
        }
   // printf("\n read receive ACK-device address(read)! \n");

        Data32=IORD( i2c_base, 3);
 40207e0:	a0800037 	ldwio	r2,0(r20)
        *(pData8+i) =  Data32 & 0xff;
 40207e4:	a8800005 	stb	r2,0(r21)
 40207e8:	ad400044 	addi	r21,r21,1
//   printf("\n read receive ACK-device address(read)! \n");

       //read the rxr data

#if 1
    for(i=0;i<nReadLength;i++){
 40207ec:	d8800a17 	ldw	r2,40(sp)
 40207f0:	98800e0e 	bge	r19,r2,402082c <OC_I2CL_Read+0x148>
  // printf("\n read receive ACK-device address(read)! \n");
   //set the RD and ACK bit(bit5 and bit3)
    	IOWR( i2c_base, 4,((i+1) == nReadLength)?0x28:0x20);
 40207f4:	d8800a17 	ldw	r2,40(sp)
 40207f8:	9cc00044 	addi	r19,r19,1
 40207fc:	14c00226 	beq	r2,r19,4020808 <OC_I2CL_Read+0x124>
 4020800:	00800804 	movi	r2,32
 4020804:	00000106 	br	402080c <OC_I2CL_Read+0x128>
 4020808:	00800a04 	movi	r2,40
 402080c:	88800035 	stwio	r2,0(r17)

        if (!ACK_judge_for_read( i2c_base)){
 4020810:	9009883a 	mov	r4,r18
 4020814:	40203280 	call	4020328 <ACK_judge_for_read>
 4020818:	1021883a 	mov	r16,r2
 402081c:	103ff01e 	bne	r2,zero,40207e0 <__alt_data_end+0xfffe07e0>
            printf("OC_I2CL_Read error[4]\r\n");
 4020820:	010100b4 	movhi	r4,1026
 4020824:	210b4f04 	addi	r4,r4,11580
 4020828:	003feb06 	br	40207d8 <__alt_data_end+0xfffe07d8>
#define TRUE 1
#define FALSE 0

bool Write32_Data(alt_32 base_address, alt_32 offset_address, alt_32 Data){
	bool bPass;
    IOWR(base_address, offset_address,Data);
 402082c:	00801004 	movi	r2,64
 4020830:	88800035 	stwio	r2,0(r17)

   if (!Write32_Data( i2c_base, 4,0x40))
       return FALSE;

   //OS_msleep(1);
    usleep(SLEEP_TIME);
 4020834:	01003e84 	movi	r4,250
 4020838:	40229880 	call	4022988 <usleep>

   return TRUE;
 402083c:	04000044 	movi	r16,1

}
 4020840:	8005883a 	mov	r2,r16
 4020844:	dfc00917 	ldw	ra,36(sp)
 4020848:	df000817 	ldw	fp,32(sp)
 402084c:	ddc00717 	ldw	r23,28(sp)
 4020850:	dd800617 	ldw	r22,24(sp)
 4020854:	dd400517 	ldw	r21,20(sp)
 4020858:	dd000417 	ldw	r20,16(sp)
 402085c:	dcc00317 	ldw	r19,12(sp)
 4020860:	dc800217 	ldw	r18,8(sp)
 4020864:	dc400117 	ldw	r17,4(sp)
 4020868:	dc000017 	ldw	r16,0(sp)
 402086c:	dec00a04 	addi	sp,sp,40
 4020870:	f800283a 	ret

04020874 <Focus_Init>:
// please observe focus performance when change the scal ,scal_f. or when change camera frame rate
alt_u8  focus_scal   =   4;  // scan 0 -> 1023 , step: SCAL , to find STEP_UP
alt_u8  focus_scal_f =   1;  //  scan STEP_UP + - SCAL/2 , step: SCAL_F
alt_u8  focus_th     =   20;

void Focus_Init(void){
 4020874:	defffd04 	addi	sp,sp,-12
  // please look at TERASIC_AUTO_FOCUS IP to see register's detail.
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_CTRL, 0);// focus mode : 1: window-screen, 0: full-screen
 4020878:	00810134 	movhi	r2,1028
// please observe focus performance when change the scal ,scal_f. or when change camera frame rate
alt_u8  focus_scal   =   4;  // scan 0 -> 1023 , step: SCAL , to find STEP_UP
alt_u8  focus_scal_f =   1;  //  scan STEP_UP + - SCAL/2 , step: SCAL_F
alt_u8  focus_th     =   20;

void Focus_Init(void){
 402087c:	dc400115 	stw	r17,4(sp)
 4020880:	dfc00215 	stw	ra,8(sp)
 4020884:	dc000015 	stw	r16,0(sp)
  // please look at TERASIC_AUTO_FOCUS IP to see register's detail.
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_CTRL, 0);// focus mode : 1: window-screen, 0: full-screen
 4020888:	0023883a 	mov	r17,zero
 402088c:	10841904 	addi	r2,r2,4196
 4020890:	14400035 	stwio	r17,0(r2)
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_FOCUS_W, focus_width);// focus_width
 4020894:	d0e0018b 	ldhu	r3,-32762(gp)
 4020898:	00810134 	movhi	r2,1028
 402089c:	10841a04 	addi	r2,r2,4200
 40208a0:	10c00035 	stwio	r3,0(r2)
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_FOCUS_H, focus_height);// focus_height
 40208a4:	d0e0010b 	ldhu	r3,-32764(gp)
 40208a8:	00810134 	movhi	r2,1028
 40208ac:	10841b04 	addi	r2,r2,4204
 40208b0:	10c00035 	stwio	r3,0(r2)
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_FOCUS_X_START, video_w/2-focus_width/2);//x_start
 40208b4:	d0a0028b 	ldhu	r2,-32758(gp)
 40208b8:	1006d07a 	srli	r3,r2,1
 40208bc:	d0a0018b 	ldhu	r2,-32762(gp)
 40208c0:	1004d07a 	srli	r2,r2,1
 40208c4:	1885c83a 	sub	r2,r3,r2
 40208c8:	00c10134 	movhi	r3,1028
 40208cc:	18c41c04 	addi	r3,r3,4208
 40208d0:	18800035 	stwio	r2,0(r3)
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_FOCUS_Y_START, video_h/2-focus_height/2);// y_start
 40208d4:	d0a0020b 	ldhu	r2,-32760(gp)
 40208d8:	1006d07a 	srli	r3,r2,1
 40208dc:	d0a0010b 	ldhu	r2,-32764(gp)
 40208e0:	1004d07a 	srli	r2,r2,1
 40208e4:	1885c83a 	sub	r2,r3,r2
 40208e8:	00c10134 	movhi	r3,1028
 40208ec:	18c41d04 	addi	r3,r3,4212
 40208f0:	18800035 	stwio	r2,0(r3)

  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_SCAL, focus_scal*256 + focus_scal_f); // scan 0 -> 1023 , step: SCAL , to find STEP_UP
 40208f4:	d0a00083 	ldbu	r2,-32766(gp)
 40208f8:	1006923a 	slli	r3,r2,8
 40208fc:	d0a00043 	ldbu	r2,-32767(gp)
 4020900:	1885883a 	add	r2,r3,r2
 4020904:	00c10134 	movhi	r3,1028
 4020908:	18c41e04 	addi	r3,r3,4216
 402090c:	18800035 	stwio	r2,0(r3)
                                                                          //  scan STEP_UP + - SCAL/2 , step: SCAL_F
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_TH, focus_th);
 4020910:	d0e00003 	ldbu	r3,-32768(gp)
 4020914:	00810134 	movhi	r2,1028
 4020918:	10841f04 	addi	r2,r2,4220
 402091c:	10c00035 	stwio	r3,0(r2)

  //////////// focus at initial time
  usleep(100);
 4020920:	01001904 	movi	r4,100
 4020924:	40229880 	call	4022988 <usleep>
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 1);
 4020928:	04010134 	movhi	r16,1028
 402092c:	84041804 	addi	r16,r16,4192
 4020930:	00800044 	movi	r2,1
 4020934:	80800035 	stwio	r2,0(r16)
  usleep(2);
 4020938:	01000084 	movi	r4,2
 402093c:	40229880 	call	4022988 <usleep>
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 0);
 4020940:	84400035 	stwio	r17,0(r16)
}
 4020944:	dfc00217 	ldw	ra,8(sp)
 4020948:	dc400117 	ldw	r17,4(sp)
 402094c:	dc000017 	ldw	r16,0(sp)
 4020950:	dec00304 	addi	sp,sp,12
 4020954:	f800283a 	ret

04020958 <Focus_Released>:

int Focus_Released(void){
  int Released = FALSE;
  alt_u32 TimeOut;

  TimeOut = alt_nticks() + alt_ticks_per_second()*8;
 4020958:	d0a07517 	ldw	r2,-32300(gp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 402095c:	d0e07417 	ldw	r3,-32304(gp)
   }
   return end_focus;

}

int Focus_Released(void){
 4020960:	defffe04 	addi	sp,sp,-8
  int Released = FALSE;
  alt_u32 TimeOut;

  TimeOut = alt_nticks() + alt_ticks_per_second()*8;
 4020964:	100490fa 	slli	r2,r2,3

  while((IORD(TERASIC_AUTO_FOCUS_0_BASE,REG_STATUS)&0x8000) ==0 && alt_nticks() < TimeOut ); // waiting for VCM release I2C bus
 4020968:	01010134 	movhi	r4,1028
   }
   return end_focus;

}

int Focus_Released(void){
 402096c:	dfc00115 	stw	ra,4(sp)
 4020970:	dc000015 	stw	r16,0(sp)
  int Released = FALSE;
  alt_u32 TimeOut;

  TimeOut = alt_nticks() + alt_ticks_per_second()*8;
 4020974:	10c5883a 	add	r2,r2,r3

  while((IORD(TERASIC_AUTO_FOCUS_0_BASE,REG_STATUS)&0x8000) ==0 && alt_nticks() < TimeOut ); // waiting for VCM release I2C bus
 4020978:	21041804 	addi	r4,r4,4192
 402097c:	20c00037 	ldwio	r3,0(r4)
 4020980:	18e0000c 	andi	r3,r3,32768
 4020984:	1800021e 	bne	r3,zero,4020990 <Focus_Released+0x38>
 4020988:	d0e07417 	ldw	r3,-32304(gp)
 402098c:	18bffb36 	bltu	r3,r2,402097c <__alt_data_end+0xfffe097c>
 4020990:	d0e07417 	ldw	r3,-32304(gp)

  if(alt_nticks() < TimeOut ) Released = TRUE;
 4020994:	18800536 	bltu	r3,r2,40209ac <Focus_Released+0x54>
  else printf("\n =>Released check TimeOut!\n");
 4020998:	010100b4 	movhi	r4,1026
 402099c:	210b5504 	addi	r4,r4,11604
 40209a0:	4021e600 	call	4021e60 <puts>
   return end_focus;

}

int Focus_Released(void){
  int Released = FALSE;
 40209a4:	0021883a 	mov	r16,zero
 40209a8:	00000106 	br	40209b0 <Focus_Released+0x58>

  TimeOut = alt_nticks() + alt_ticks_per_second()*8;

  while((IORD(TERASIC_AUTO_FOCUS_0_BASE,REG_STATUS)&0x8000) ==0 && alt_nticks() < TimeOut ); // waiting for VCM release I2C bus

  if(alt_nticks() < TimeOut ) Released = TRUE;
 40209ac:	04000044 	movi	r16,1
  else printf("\n =>Released check TimeOut!\n");

  usleep(10000);
 40209b0:	0109c404 	movi	r4,10000
 40209b4:	40229880 	call	4022988 <usleep>

  return Released;
}
 40209b8:	8005883a 	mov	r2,r16
 40209bc:	dfc00117 	ldw	ra,4(sp)
 40209c0:	dc000017 	ldw	r16,0(sp)
 40209c4:	dec00204 	addi	sp,sp,8
 40209c8:	f800283a 	ret

040209cc <Focus_Window>:
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 1);
  usleep(2);
  IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 0);
}

alt_u16 Focus_Window(int x,int y){
 40209cc:	defffd04 	addi	sp,sp,-12
 40209d0:	dc400115 	stw	r17,4(sp)
 40209d4:	dc000015 	stw	r16,0(sp)
 40209d8:	dfc00215 	stw	ra,8(sp)
 40209dc:	2023883a 	mov	r17,r4
 40209e0:	2821883a 	mov	r16,r5
   alt_u16 x_start,y_start;
   alt_u16 end_focus;

   if(Focus_Released()) { // pre focus done
 40209e4:	40209580 	call	4020958 <Focus_Released>
 40209e8:	10004326 	beq	r2,zero,4020af8 <Focus_Window+0x12c>
	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_CTRL, 1);// focus mode : 1: window-screen, 0: full-screen
 40209ec:	00810134 	movhi	r2,1028
 40209f0:	10841904 	addi	r2,r2,4196
 40209f4:	00c00044 	movi	r3,1
 40209f8:	10c00035 	stwio	r3,0(r2)

	   if(( x -  focus_width/2) < 0 ) x_start = 0;
 40209fc:	d120018b 	ldhu	r4,-32762(gp)
 4020a00:	20bfffcc 	andi	r2,r4,65535
 4020a04:	10c4d83a 	srl	r2,r2,r3
 4020a08:	117fffcc 	andi	r5,r2,65535
 4020a0c:	8947c83a 	sub	r3,r17,r5
 4020a10:	18000916 	blt	r3,zero,4020a38 <Focus_Window+0x6c>
	   else if(( x + focus_width/2 ) > video_w )  x_start = video_w -1 -focus_width;
 4020a14:	d0e0028b 	ldhu	r3,-32758(gp)
 4020a18:	2c4b883a 	add	r5,r5,r17
 4020a1c:	19bfffcc 	andi	r6,r3,65535
 4020a20:	3140030e 	bge	r6,r5,4020a30 <Focus_Window+0x64>
 4020a24:	18ffffc4 	addi	r3,r3,-1
 4020a28:	1923c83a 	sub	r17,r3,r4
 4020a2c:	00000306 	br	4020a3c <Focus_Window+0x70>
	   else x_start = x - focus_width/2;
 4020a30:	88a3c83a 	sub	r17,r17,r2
 4020a34:	00000106 	br	4020a3c <Focus_Window+0x70>
   alt_u16 end_focus;

   if(Focus_Released()) { // pre focus done
	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_CTRL, 1);// focus mode : 1: window-screen, 0: full-screen

	   if(( x -  focus_width/2) < 0 ) x_start = 0;
 4020a38:	0023883a 	mov	r17,zero
	   else if(( x + focus_width/2 ) > video_w )  x_start = video_w -1 -focus_width;
	   else x_start = x - focus_width/2;

	   if(( y -  focus_height/2) < 0 ) y_start = 0;
 4020a3c:	d160010b 	ldhu	r5,-32764(gp)
 4020a40:	28bfffcc 	andi	r2,r5,65535
 4020a44:	1004d07a 	srli	r2,r2,1
 4020a48:	113fffcc 	andi	r4,r2,65535
 4020a4c:	8107c83a 	sub	r3,r16,r4
 4020a50:	18000916 	blt	r3,zero,4020a78 <Focus_Window+0xac>
	   else if(( y + focus_height/2 ) > video_h )  y_start = video_h -1 -focus_height;
 4020a54:	d0e0020b 	ldhu	r3,-32760(gp)
 4020a58:	2409883a 	add	r4,r4,r16
 4020a5c:	19bfffcc 	andi	r6,r3,65535
 4020a60:	3100030e 	bge	r6,r4,4020a70 <Focus_Window+0xa4>
 4020a64:	18ffffc4 	addi	r3,r3,-1
 4020a68:	1961c83a 	sub	r16,r3,r5
 4020a6c:	00000306 	br	4020a7c <Focus_Window+0xb0>
	   else y_start = y - focus_height/2;
 4020a70:	80a1c83a 	sub	r16,r16,r2
 4020a74:	00000106 	br	4020a7c <Focus_Window+0xb0>

	   if(( x -  focus_width/2) < 0 ) x_start = 0;
	   else if(( x + focus_width/2 ) > video_w )  x_start = video_w -1 -focus_width;
	   else x_start = x - focus_width/2;

	   if(( y -  focus_height/2) < 0 ) y_start = 0;
 4020a78:	0021883a 	mov	r16,zero
	   else if(( y + focus_height/2 ) > video_h )  y_start = video_h -1 -focus_height;
	   else y_start = y - focus_height/2;

	   printf("x_start= %d,y_start= %d\n",x_start,y_start);
 4020a7c:	8c7fffcc 	andi	r17,r17,65535
 4020a80:	843fffcc 	andi	r16,r16,65535
 4020a84:	010100b4 	movhi	r4,1026
 4020a88:	800d883a 	mov	r6,r16
 4020a8c:	880b883a 	mov	r5,r17
 4020a90:	210b5d04 	addi	r4,r4,11636
 4020a94:	4021d700 	call	4021d70 <printf>

	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_FOCUS_X_START, x_start);//x_start
 4020a98:	00810134 	movhi	r2,1028
 4020a9c:	10841c04 	addi	r2,r2,4208
 4020aa0:	14400035 	stwio	r17,0(r2)
	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_FOCUS_Y_START, y_start);//y_start
 4020aa4:	00810134 	movhi	r2,1028
 4020aa8:	10841d04 	addi	r2,r2,4212
 4020aac:	14000035 	stwio	r16,0(r2)

	   usleep(10);
 4020ab0:	01000284 	movi	r4,10
 4020ab4:	40229880 	call	4022988 <usleep>

	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 1);
 4020ab8:	04010134 	movhi	r16,1028
 4020abc:	84041804 	addi	r16,r16,4192
 4020ac0:	00800044 	movi	r2,1
 4020ac4:	80800035 	stwio	r2,0(r16)
	   usleep(2);
 4020ac8:	01000084 	movi	r4,2
 4020acc:	40229880 	call	4022988 <usleep>
	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 0);
 4020ad0:	80000035 	stwio	zero,0(r16)
	   Focus_Released();
 4020ad4:	40209580 	call	4020958 <Focus_Released>

	   end_focus = IORD(TERASIC_AUTO_FOCUS_0_BASE,REG_STATUS)&0x0FFF;
 4020ad8:	84000037 	ldwio	r16,0(r16)
	   printf("end_focus = %d \n",end_focus);
 4020adc:	010100b4 	movhi	r4,1026
	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 1);
	   usleep(2);
	   IOWR(TERASIC_AUTO_FOCUS_0_BASE,REG_GO, 0);
	   Focus_Released();

	   end_focus = IORD(TERASIC_AUTO_FOCUS_0_BASE,REG_STATUS)&0x0FFF;
 4020ae0:	8403ffcc 	andi	r16,r16,4095
	   printf("end_focus = %d \n",end_focus);
 4020ae4:	800b883a 	mov	r5,r16
 4020ae8:	210b6404 	addi	r4,r4,11664
 4020aec:	4021d700 	call	4021d70 <printf>

	   return end_focus;
 4020af0:	8005883a 	mov	r2,r16
 4020af4:	00000106 	br	4020afc <Focus_Window+0x130>

   }
   return end_focus;
 4020af8:	0005883a 	mov	r2,zero

}
 4020afc:	dfc00217 	ldw	ra,8(sp)
 4020b00:	dc400117 	ldw	r17,4(sp)
 4020b04:	dc000017 	ldw	r16,0(sp)
 4020b08:	dec00304 	addi	sp,sp,12
 4020b0c:	f800283a 	ret

04020b10 <mipi_clear_error>:
#define MIPI_REG_CSIErrEn		0x0066
#define MIPI_REG_MDLSynErr		0x0068
#define MIPI_REG_FrmErrCnt		0x0080
#define MIPI_REG_MDLErrCnt		0x0090

void mipi_clear_error(void){
 4020b10:	defffe04 	addi	sp,sp,-8
	MipiBridgeRegWrite(MIPI_REG_CSIStatus,0x01FF); // clear error
 4020b14:	01407fc4 	movi	r5,511
 4020b18:	01001904 	movi	r4,100
#define MIPI_REG_CSIErrEn		0x0066
#define MIPI_REG_MDLSynErr		0x0068
#define MIPI_REG_FrmErrCnt		0x0080
#define MIPI_REG_MDLErrCnt		0x0090

void mipi_clear_error(void){
 4020b1c:	dfc00115 	stw	ra,4(sp)
 4020b20:	dc000015 	stw	r16,0(sp)
	MipiBridgeRegWrite(MIPI_REG_CSIStatus,0x01FF); // clear error
 4020b24:	40210340 	call	4021034 <MipiBridgeRegWrite>
	MipiBridgeRegWrite(MIPI_REG_MDLSynErr,0x0000); // clear error
 4020b28:	000b883a 	mov	r5,zero
 4020b2c:	01001a04 	movi	r4,104
 4020b30:	40210340 	call	4021034 <MipiBridgeRegWrite>
	MipiBridgeRegWrite(MIPI_REG_FrmErrCnt,0x0000); // clear error
 4020b34:	000b883a 	mov	r5,zero
 4020b38:	01002004 	movi	r4,128
 4020b3c:	40210340 	call	4021034 <MipiBridgeRegWrite>
	MipiBridgeRegWrite(MIPI_REG_MDLErrCnt, 0x0000); // clear error
 4020b40:	04002404 	movi	r16,144
 4020b44:	8009883a 	mov	r4,r16
 4020b48:	000b883a 	mov	r5,zero
 4020b4c:	40210340 	call	4021034 <MipiBridgeRegWrite>

  	MipiBridgeRegWrite(0x0082,0x00);
 4020b50:	000b883a 	mov	r5,zero
 4020b54:	01002084 	movi	r4,130
 4020b58:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x0084,0x00);
 4020b5c:	000b883a 	mov	r5,zero
 4020b60:	01002104 	movi	r4,132
 4020b64:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x0086,0x00);
 4020b68:	000b883a 	mov	r5,zero
 4020b6c:	01002184 	movi	r4,134
 4020b70:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x0088,0x00);
 4020b74:	000b883a 	mov	r5,zero
 4020b78:	01002204 	movi	r4,136
 4020b7c:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x008A,0x00);
 4020b80:	000b883a 	mov	r5,zero
 4020b84:	01002284 	movi	r4,138
 4020b88:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x008C,0x00);
 4020b8c:	000b883a 	mov	r5,zero
 4020b90:	01002304 	movi	r4,140
 4020b94:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x008E,0x00);
 4020b98:	000b883a 	mov	r5,zero
 4020b9c:	01002384 	movi	r4,142
 4020ba0:	40210340 	call	4021034 <MipiBridgeRegWrite>
  	MipiBridgeRegWrite(0x0090,0x00);
 4020ba4:	000b883a 	mov	r5,zero
 4020ba8:	8009883a 	mov	r4,r16
}
 4020bac:	dfc00117 	ldw	ra,4(sp)
 4020bb0:	dc000017 	ldw	r16,0(sp)
 4020bb4:	dec00204 	addi	sp,sp,8
  	MipiBridgeRegWrite(0x0086,0x00);
  	MipiBridgeRegWrite(0x0088,0x00);
  	MipiBridgeRegWrite(0x008A,0x00);
  	MipiBridgeRegWrite(0x008C,0x00);
  	MipiBridgeRegWrite(0x008E,0x00);
  	MipiBridgeRegWrite(0x0090,0x00);
 4020bb8:	40210341 	jmpi	4021034 <MipiBridgeRegWrite>

04020bbc <mipi_show_error_info>:
}

void mipi_show_error_info(void){
 4020bbc:	defff904 	addi	sp,sp,-28

	alt_u16 PHY_status, SCI_status, MDLSynErr, FrmErrCnt, MDLErrCnt;

	PHY_status = MipiBridgeRegRead(MIPI_REG_PHYSta);
 4020bc0:	01001884 	movi	r4,98
  	MipiBridgeRegWrite(0x008C,0x00);
  	MipiBridgeRegWrite(0x008E,0x00);
  	MipiBridgeRegWrite(0x0090,0x00);
}

void mipi_show_error_info(void){
 4020bc4:	dfc00615 	stw	ra,24(sp)
 4020bc8:	dcc00515 	stw	r19,20(sp)
 4020bcc:	dc800415 	stw	r18,16(sp)
 4020bd0:	dc400315 	stw	r17,12(sp)
 4020bd4:	dc000215 	stw	r16,8(sp)

	alt_u16 PHY_status, SCI_status, MDLSynErr, FrmErrCnt, MDLErrCnt;

	PHY_status = MipiBridgeRegRead(MIPI_REG_PHYSta);
 4020bd8:	402106c0 	call	402106c <MipiBridgeRegRead>
	SCI_status = MipiBridgeRegRead(MIPI_REG_CSIStatus);
 4020bdc:	01001904 	movi	r4,100

void mipi_show_error_info(void){

	alt_u16 PHY_status, SCI_status, MDLSynErr, FrmErrCnt, MDLErrCnt;

	PHY_status = MipiBridgeRegRead(MIPI_REG_PHYSta);
 4020be0:	1023883a 	mov	r17,r2
	SCI_status = MipiBridgeRegRead(MIPI_REG_CSIStatus);
 4020be4:	402106c0 	call	402106c <MipiBridgeRegRead>
	MDLSynErr = MipiBridgeRegRead(MIPI_REG_MDLSynErr);
 4020be8:	01001a04 	movi	r4,104
void mipi_show_error_info(void){

	alt_u16 PHY_status, SCI_status, MDLSynErr, FrmErrCnt, MDLErrCnt;

	PHY_status = MipiBridgeRegRead(MIPI_REG_PHYSta);
	SCI_status = MipiBridgeRegRead(MIPI_REG_CSIStatus);
 4020bec:	1025883a 	mov	r18,r2
	MDLSynErr = MipiBridgeRegRead(MIPI_REG_MDLSynErr);
 4020bf0:	402106c0 	call	402106c <MipiBridgeRegRead>
	FrmErrCnt = MipiBridgeRegRead(MIPI_REG_FrmErrCnt);
 4020bf4:	01002004 	movi	r4,128

	alt_u16 PHY_status, SCI_status, MDLSynErr, FrmErrCnt, MDLErrCnt;

	PHY_status = MipiBridgeRegRead(MIPI_REG_PHYSta);
	SCI_status = MipiBridgeRegRead(MIPI_REG_CSIStatus);
	MDLSynErr = MipiBridgeRegRead(MIPI_REG_MDLSynErr);
 4020bf8:	1027883a 	mov	r19,r2
	FrmErrCnt = MipiBridgeRegRead(MIPI_REG_FrmErrCnt);
 4020bfc:	402106c0 	call	402106c <MipiBridgeRegRead>
	MDLErrCnt = MipiBridgeRegRead(MIPI_REG_MDLErrCnt);
 4020c00:	01002404 	movi	r4,144
	alt_u16 PHY_status, SCI_status, MDLSynErr, FrmErrCnt, MDLErrCnt;

	PHY_status = MipiBridgeRegRead(MIPI_REG_PHYSta);
	SCI_status = MipiBridgeRegRead(MIPI_REG_CSIStatus);
	MDLSynErr = MipiBridgeRegRead(MIPI_REG_MDLSynErr);
	FrmErrCnt = MipiBridgeRegRead(MIPI_REG_FrmErrCnt);
 4020c04:	1021883a 	mov	r16,r2
	MDLErrCnt = MipiBridgeRegRead(MIPI_REG_MDLErrCnt);
 4020c08:	402106c0 	call	402106c <MipiBridgeRegRead>
	printf("PHY_status=%xh, CSI_status=%xh, MDLSynErr=%xh, FrmErrCnt=%xh, MDLErrCnt=%xh\r\n", PHY_status, SCI_status, MDLSynErr,FrmErrCnt, MDLErrCnt);
 4020c0c:	10bfffcc 	andi	r2,r2,65535
 4020c10:	843fffcc 	andi	r16,r16,65535
 4020c14:	010100b4 	movhi	r4,1026
 4020c18:	d8800115 	stw	r2,4(sp)
 4020c1c:	dc000015 	stw	r16,0(sp)
 4020c20:	99ffffcc 	andi	r7,r19,65535
 4020c24:	91bfffcc 	andi	r6,r18,65535
 4020c28:	897fffcc 	andi	r5,r17,65535
 4020c2c:	210b6904 	addi	r4,r4,11684
 4020c30:	4021d700 	call	4021d70 <printf>
}
 4020c34:	dfc00617 	ldw	ra,24(sp)
 4020c38:	dcc00517 	ldw	r19,20(sp)
 4020c3c:	dc800417 	ldw	r18,16(sp)
 4020c40:	dc400317 	ldw	r17,12(sp)
 4020c44:	dc000217 	ldw	r16,8(sp)
 4020c48:	dec00704 	addi	sp,sp,28
 4020c4c:	f800283a 	ret

04020c50 <mipi_show_error_info_more>:

void mipi_show_error_info_more(void){
 4020c50:	deffff04 	addi	sp,sp,-4
    printf("FrmErrCnt = %d\n",MipiBridgeRegRead(0x0080));
 4020c54:	01002004 	movi	r4,128
	FrmErrCnt = MipiBridgeRegRead(MIPI_REG_FrmErrCnt);
	MDLErrCnt = MipiBridgeRegRead(MIPI_REG_MDLErrCnt);
	printf("PHY_status=%xh, CSI_status=%xh, MDLSynErr=%xh, FrmErrCnt=%xh, MDLErrCnt=%xh\r\n", PHY_status, SCI_status, MDLSynErr,FrmErrCnt, MDLErrCnt);
}

void mipi_show_error_info_more(void){
 4020c58:	dfc00015 	stw	ra,0(sp)
    printf("FrmErrCnt = %d\n",MipiBridgeRegRead(0x0080));
 4020c5c:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020c60:	010100b4 	movhi	r4,1026
 4020c64:	117fffcc 	andi	r5,r2,65535
 4020c68:	210b7d04 	addi	r4,r4,11764
 4020c6c:	4021d700 	call	4021d70 <printf>
    printf("CRCErrCnt = %d\n",MipiBridgeRegRead(0x0082));
 4020c70:	01002084 	movi	r4,130
 4020c74:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020c78:	010100b4 	movhi	r4,1026
 4020c7c:	117fffcc 	andi	r5,r2,65535
 4020c80:	210b8104 	addi	r4,r4,11780
 4020c84:	4021d700 	call	4021d70 <printf>
    printf("CorErrCnt = %d\n",MipiBridgeRegRead(0x0084));
 4020c88:	01002104 	movi	r4,132
 4020c8c:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020c90:	010100b4 	movhi	r4,1026
 4020c94:	117fffcc 	andi	r5,r2,65535
 4020c98:	210b8504 	addi	r4,r4,11796
 4020c9c:	4021d700 	call	4021d70 <printf>
    printf("HdrErrCnt = %d\n",MipiBridgeRegRead(0x0086));
 4020ca0:	01002184 	movi	r4,134
 4020ca4:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020ca8:	010100b4 	movhi	r4,1026
 4020cac:	117fffcc 	andi	r5,r2,65535
 4020cb0:	210b8904 	addi	r4,r4,11812
 4020cb4:	4021d700 	call	4021d70 <printf>
    printf("EIDErrCnt = %d\n",MipiBridgeRegRead(0x0088));
 4020cb8:	01002204 	movi	r4,136
 4020cbc:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020cc0:	010100b4 	movhi	r4,1026
 4020cc4:	117fffcc 	andi	r5,r2,65535
 4020cc8:	210b8d04 	addi	r4,r4,11828
 4020ccc:	4021d700 	call	4021d70 <printf>
    printf("CtlErrCnt = %d\n",MipiBridgeRegRead(0x008A));
 4020cd0:	01002284 	movi	r4,138
 4020cd4:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020cd8:	010100b4 	movhi	r4,1026
 4020cdc:	117fffcc 	andi	r5,r2,65535
 4020ce0:	210b9104 	addi	r4,r4,11844
 4020ce4:	4021d700 	call	4021d70 <printf>
    printf("SoTErrCnt = %d\n",MipiBridgeRegRead(0x008C));
 4020ce8:	01002304 	movi	r4,140
 4020cec:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020cf0:	010100b4 	movhi	r4,1026
 4020cf4:	117fffcc 	andi	r5,r2,65535
 4020cf8:	210b9504 	addi	r4,r4,11860
 4020cfc:	4021d700 	call	4021d70 <printf>
    printf("SynErrCnt = %d\n",MipiBridgeRegRead(0x008E));
 4020d00:	01002384 	movi	r4,142
 4020d04:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020d08:	010100b4 	movhi	r4,1026
 4020d0c:	117fffcc 	andi	r5,r2,65535
 4020d10:	210b9904 	addi	r4,r4,11876
 4020d14:	4021d700 	call	4021d70 <printf>
    printf("MDLErrCnt = %d\n",MipiBridgeRegRead(0x0090));
 4020d18:	01002404 	movi	r4,144
 4020d1c:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020d20:	010100b4 	movhi	r4,1026
 4020d24:	117fffcc 	andi	r5,r2,65535
 4020d28:	210b9d04 	addi	r4,r4,11892
 4020d2c:	4021d700 	call	4021d70 <printf>
    printf("FIFOSTATUS = %d\n",MipiBridgeRegRead(0x00F8));
 4020d30:	01003e04 	movi	r4,248
 4020d34:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020d38:	010100b4 	movhi	r4,1026
 4020d3c:	117fffcc 	andi	r5,r2,65535
 4020d40:	210ba104 	addi	r4,r4,11908
 4020d44:	4021d700 	call	4021d70 <printf>
    printf("DataType = 0x%04x\n",MipiBridgeRegRead(0x006A));
 4020d48:	01001a84 	movi	r4,106
 4020d4c:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020d50:	010100b4 	movhi	r4,1026
 4020d54:	117fffcc 	andi	r5,r2,65535
 4020d58:	210ba604 	addi	r4,r4,11928
 4020d5c:	4021d700 	call	4021d70 <printf>
    printf("CSIPktLen = %d\n",MipiBridgeRegRead(0x006E));
 4020d60:	01001b84 	movi	r4,110
 4020d64:	402106c0 	call	402106c <MipiBridgeRegRead>
 4020d68:	010100b4 	movhi	r4,1026
 4020d6c:	117fffcc 	andi	r5,r2,65535
 4020d70:	210bab04 	addi	r4,r4,11948
}
 4020d74:	dfc00017 	ldw	ra,0(sp)
 4020d78:	dec00104 	addi	sp,sp,4
    printf("SoTErrCnt = %d\n",MipiBridgeRegRead(0x008C));
    printf("SynErrCnt = %d\n",MipiBridgeRegRead(0x008E));
    printf("MDLErrCnt = %d\n",MipiBridgeRegRead(0x0090));
    printf("FIFOSTATUS = %d\n",MipiBridgeRegRead(0x00F8));
    printf("DataType = 0x%04x\n",MipiBridgeRegRead(0x006A));
    printf("CSIPktLen = %d\n",MipiBridgeRegRead(0x006E));
 4020d7c:	4021d701 	jmpi	4021d70 <printf>

04020d80 <MIPI_Init>:


bool MIPI_Init(void){
	bool bSuccess;

	bSuccess = oc_i2c_init_ex(I2C_OPENCORES_MIPI_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4020d80:	018001b4 	movhi	r6,6
 4020d84:	0140bef4 	movhi	r5,763
 4020d88:	01010134 	movhi	r4,1028
    printf("CSIPktLen = %d\n",MipiBridgeRegRead(0x006E));
}



bool MIPI_Init(void){
 4020d8c:	defffe04 	addi	sp,sp,-8
	bool bSuccess;

	bSuccess = oc_i2c_init_ex(I2C_OPENCORES_MIPI_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4020d90:	3186a004 	addi	r6,r6,6784
 4020d94:	297c2004 	addi	r5,r5,-3968
 4020d98:	21042804 	addi	r4,r4,4256
    printf("CSIPktLen = %d\n",MipiBridgeRegRead(0x006E));
}



bool MIPI_Init(void){
 4020d9c:	dc000015 	stw	r16,0(sp)
 4020da0:	dfc00115 	stw	ra,4(sp)
	bool bSuccess;

	bSuccess = oc_i2c_init_ex(I2C_OPENCORES_MIPI_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4020da4:	40200a00 	call	40200a0 <oc_i2c_init_ex>
 4020da8:	1021883a 	mov	r16,r2
	if (!bSuccess)
 4020dac:	1000031e 	bne	r2,zero,4020dbc <MIPI_Init+0x3c>
		printf("failed to init MIPI- Bridge i2c\r\n");
 4020db0:	010100b4 	movhi	r4,1026
 4020db4:	210baf04 	addi	r4,r4,11964
 4020db8:	4021e600 	call	4021e60 <puts>

    usleep(50*1000);
 4020dbc:	0130d414 	movui	r4,50000
 4020dc0:	40229880 	call	4022988 <usleep>
    MipiBridgeInit();
 4020dc4:	40210b00 	call	40210b0 <MipiBridgeInit>

    usleep(500*1000);
 4020dc8:	01000234 	movhi	r4,8
 4020dcc:	21284804 	addi	r4,r4,-24288
 4020dd0:	40229880 	call	4022988 <usleep>

    MipiCameraInit();
 4020dd4:	40216300 	call	4021630 <MipiCameraInit>
    MIPI_BIN_LEVEL(DEFAULT_LEVEL);
 4020dd8:	010000c4 	movi	r4,3
 4020ddc:	40214a40 	call	40214a4 <MIPI_BIN_LEVEL>

 	usleep(1000);
 4020de0:	0100fa04 	movi	r4,1000
 4020de4:	40229880 	call	4022988 <usleep>

	return bSuccess;
}
 4020de8:	8005883a 	mov	r2,r16
 4020dec:	dfc00117 	ldw	ra,4(sp)
 4020df0:	dc000017 	ldw	r16,0(sp)
 4020df4:	dec00204 	addi	sp,sp,8
 4020df8:	f800283a 	ret

04020dfc <main>:




int main()
{
 4020dfc:	defffa04 	addi	sp,sp,-24

	fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);
 4020e00:	01900004 	movi	r6,16384
 4020e04:	01400104 	movi	r5,4
 4020e08:	0009883a 	mov	r4,zero




int main()
{
 4020e0c:	dfc00515 	stw	ra,20(sp)
 4020e10:	dc800215 	stw	r18,8(sp)
 4020e14:	dd000415 	stw	r20,16(sp)
 4020e18:	dcc00315 	stw	r19,12(sp)
 4020e1c:	dc400115 	stw	r17,4(sp)
 4020e20:	dc000015 	stw	r16,0(sp)

	fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);
 4020e24:	40226480 	call	4022648 <fcntl>

  printf("DE10-LITE D8M VGA Demo\n");
 4020e28:	010100b4 	movhi	r4,1026
 4020e2c:	210bb804 	addi	r4,r4,12000
 4020e30:	4021e600 	call	4021e60 <puts>
  printf("Imperial College EEE2 Project version\n");
 4020e34:	010100b4 	movhi	r4,1026
 4020e38:	210bbe04 	addi	r4,r4,12024
  IOWR(MIPI_PWDN_N_BASE, 0x00, 0x00);
 4020e3c:	04810134 	movhi	r18,1028
{

	fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);

  printf("DE10-LITE D8M VGA Demo\n");
  printf("Imperial College EEE2 Project version\n");
 4020e40:	4021e600 	call	4021e60 <puts>
  IOWR(MIPI_PWDN_N_BASE, 0x00, 0x00);
 4020e44:	94843004 	addi	r18,r18,4288
 4020e48:	90000035 	stwio	zero,0(r18)
  IOWR(MIPI_RESET_N_BASE, 0x00, 0x00);
 4020e4c:	04010134 	movhi	r16,1028
 4020e50:	84043404 	addi	r16,r16,4304
 4020e54:	80000035 	stwio	zero,0(r16)

  usleep(2000);
 4020e58:	0101f404 	movi	r4,2000
 4020e5c:	40229880 	call	4022988 <usleep>
  IOWR(MIPI_PWDN_N_BASE, 0x00, 0xFF);
 4020e60:	04403fc4 	movi	r17,255
 4020e64:	94400035 	stwio	r17,0(r18)
  usleep(2000);
 4020e68:	0101f404 	movi	r4,2000
 4020e6c:	40229880 	call	4022988 <usleep>
  IOWR(MIPI_RESET_N_BASE, 0x00, 0xFF);
 4020e70:	84400035 	stwio	r17,0(r16)

  printf("Image Processor ID: %x\n",IORD(0x42000,EEE_IMGPROC_ID));
 4020e74:	00800134 	movhi	r2,4
 4020e78:	10880204 	addi	r2,r2,8200
 4020e7c:	11400037 	ldwio	r5,0(r2)
 4020e80:	010100b4 	movhi	r4,1026
 4020e84:	210bc804 	addi	r4,r4,12064
 4020e88:	4021d700 	call	4021d70 <printf>
  //printf("Image Processor ID: %x\n",IORD(EEE_IMGPROC_0_BASE,EEE_IMGPROC_ID)); //Don't know why this doesn't work - definition is in system.h in BSP


  usleep(2000);
 4020e8c:	0101f404 	movi	r4,2000
 4020e90:	40229880 	call	4022988 <usleep>


  // MIPI Init
   if (!MIPI_Init()){
 4020e94:	4020d800 	call	4020d80 <MIPI_Init>
 4020e98:	1000031e 	bne	r2,zero,4020ea8 <main+0xac>
	  printf("MIPI_Init Init failed!\r\n");
 4020e9c:	010100b4 	movhi	r4,1026
 4020ea0:	210bce04 	addi	r4,r4,12088
 4020ea4:	4021e600 	call	4021e60 <puts>
  }

 	    mipi_clear_error();
 4020ea8:	4020b100 	call	4020b10 <mipi_clear_error>
	 	usleep(50*1000);
 4020eac:	0130d414 	movui	r4,50000
 4020eb0:	40229880 	call	4022988 <usleep>
 	    mipi_clear_error();
 4020eb4:	4020b100 	call	4020b10 <mipi_clear_error>
	 	usleep(1000*1000);
 4020eb8:	010003f4 	movhi	r4,15
 4020ebc:	21109004 	addi	r4,r4,16960
 4020ec0:	40229880 	call	4022988 <usleep>
	    mipi_show_error_info();
 4020ec4:	4020bbc0 	call	4020bbc <mipi_show_error_info>
	    printf("\n");
 4020ec8:	01000284 	movi	r4,10
 4020ecc:	4021dc40 	call	4021dc4 <putchar>
        alt_u16  current_focus = 300;
    	int boundingBoxColour = 0;
    	alt_u32 exposureTime = EXPOSURE_INIT;
    	alt_u16 gain = GAIN_INIT;

        OV8865SetExposure(exposureTime);
 4020ed0:	01088004 	movi	r4,8704
 4020ed4:	40212d40 	call	40212d4 <OV8865SetExposure>
        OV8865SetGain(gain);
 4020ed8:	0100a004 	movi	r4,640
//       boundingBoxColour = ((boundingBoxColour + 1) & 0xff);
//       IOWR(0x42000, EEE_IMGPROC_BBCOL, (boundingBoxColour << 8) | (0xff - boundingBoxColour));

       //Process input commands
       int in = alt_getchar();
       switch (in) {
 4020edc:	050100b4 	movhi	r20,1026
    	int boundingBoxColour = 0;
    	alt_u32 exposureTime = EXPOSURE_INIT;
    	alt_u16 gain = GAIN_INIT;

        OV8865SetExposure(exposureTime);
        OV8865SetGain(gain);
 4020ee0:	40213740 	call	4021374 <OV8865SetGain>
        alt_u16 bin_level = DEFAULT_LEVEL;
        alt_u8  manual_focus_step = 10;
        alt_u16  current_focus = 300;
    	int boundingBoxColour = 0;
    	alt_u32 exposureTime = EXPOSURE_INIT;
    	alt_u16 gain = GAIN_INIT;
 4020ee4:	04c0a004 	movi	r19,640

        OV8865SetExposure(exposureTime);
        OV8865SetGain(gain);
        Focus_Init();
 4020ee8:	40208740 	call	4020874 <Focus_Init>
    //////////////////////////////////////////////////////////
        alt_u16 bin_level = DEFAULT_LEVEL;
        alt_u8  manual_focus_step = 10;
        alt_u16  current_focus = 300;
    	int boundingBoxColour = 0;
    	alt_u32 exposureTime = EXPOSURE_INIT;
 4020eec:	04488004 	movi	r17,8704


    //////////////////////////////////////////////////////////
        alt_u16 bin_level = DEFAULT_LEVEL;
        alt_u8  manual_focus_step = 10;
        alt_u16  current_focus = 300;
 4020ef0:	04004b04 	movi	r16,300
//       boundingBoxColour = ((boundingBoxColour + 1) & 0xff);
//       IOWR(0x42000, EEE_IMGPROC_BBCOL, (boundingBoxColour << 8) | (0xff - boundingBoxColour));

       //Process input commands
       int in = alt_getchar();
       switch (in) {
 4020ef4:	a503c604 	addi	r20,r20,3864
//       //Update the bounding box colour
//       boundingBoxColour = ((boundingBoxColour + 1) & 0xff);
//       IOWR(0x42000, EEE_IMGPROC_BBCOL, (boundingBoxColour << 8) | (0xff - boundingBoxColour));

       //Process input commands
       int in = alt_getchar();
 4020ef8:	40227000 	call	4022700 <alt_getchar>
       switch (in) {
 4020efc:	10bfe7c4 	addi	r2,r2,-97
 4020f00:	00c004c4 	movi	r3,19
 4020f04:	18804336 	bltu	r3,r2,4021014 <main+0x218>
 4020f08:	100490ba 	slli	r2,r2,2
 4020f0c:	1505883a 	add	r2,r2,r20
 4020f10:	10800017 	ldw	r2,0(r2)
 4020f14:	1000683a 	jmp	r2
 4020f18:	04020f68 	cmpgeui	r16,zero,2109
 4020f1c:	04021014 	movui	r16,2112
 4020f20:	04021014 	movui	r16,2112
 4020f24:	04020f84 	movi	r16,2110
 4020f28:	04020f7c 	xorhi	r16,zero,2109
 4020f2c:	04020fe8 	cmpgeui	r16,zero,2111
 4020f30:	04020fa8 	cmpgeui	r16,zero,2110
 4020f34:	04021014 	movui	r16,2112
 4020f38:	04021014 	movui	r16,2112
 4020f3c:	04021014 	movui	r16,2112
 4020f40:	04021014 	movui	r16,2112
 4020f44:	04021014 	movui	r16,2112
 4020f48:	04021014 	movui	r16,2112
 4020f4c:	04021014 	movui	r16,2112
 4020f50:	04021014 	movui	r16,2112
 4020f54:	04021014 	movui	r16,2112
 4020f58:	04021014 	movui	r16,2112
 4020f5c:	04020fcc 	andi	r16,zero,2111
 4020f60:	04021014 	movui	r16,2112
 4020f64:	04020fa0 	cmpeqi	r16,zero,2110
		   case 'a': {
			   //current_focus = Focus_Window(320,240);
			   Focus_Init();
 4020f68:	40208740 	call	4020874 <Focus_Init>
			   printf("Autofocused/n");
 4020f6c:	010100b4 	movhi	r4,1026
 4020f70:	210bd404 	addi	r4,r4,12112
 4020f74:	4021d700 	call	4021d70 <printf>
			   break;}
 4020f78:	00002606 	br	4021014 <main+0x218>
       	   case 'e': {
       		   exposureTime += EXPOSURE_STEP;
 4020f7c:	8c404004 	addi	r17,r17,256
 4020f80:	00000106 	br	4020f88 <main+0x18c>
       		   OV8865SetExposure(exposureTime);
       		   printf("\nExposure = %x ", exposureTime);
       	   	   break;}
       	   case 'd': {
       		   exposureTime -= EXPOSURE_STEP;
 4020f84:	8c7fc004 	addi	r17,r17,-256
       		   OV8865SetExposure(exposureTime);
 4020f88:	8809883a 	mov	r4,r17
 4020f8c:	40212d40 	call	40212d4 <OV8865SetExposure>
       		   printf("\nExposure = %x ", exposureTime);
 4020f90:	010100b4 	movhi	r4,1026
 4020f94:	880b883a 	mov	r5,r17
 4020f98:	210bd804 	addi	r4,r4,12128
 4020f9c:	00001c06 	br	4021010 <main+0x214>
       	   	   break;}
       	   case 't': {
       		   gain += GAIN_STEP;
 4020fa0:	9c801004 	addi	r18,r19,64
 4020fa4:	00000106 	br	4020fac <main+0x1b0>
       		   OV8865SetGain(gain);
       		   printf("\nGain = %x ", gain);
       	   	   break;}
       	   case 'g': {
       		   gain -= GAIN_STEP;
 4020fa8:	9cbff004 	addi	r18,r19,-64
 4020fac:	9027883a 	mov	r19,r18
       		   OV8865SetGain(gain);
 4020fb0:	94bfffcc 	andi	r18,r18,65535
 4020fb4:	9009883a 	mov	r4,r18
 4020fb8:	40213740 	call	4021374 <OV8865SetGain>
       		   printf("\nGain = %x ", gain);
 4020fbc:	010100b4 	movhi	r4,1026
 4020fc0:	900b883a 	mov	r5,r18
 4020fc4:	210bdc04 	addi	r4,r4,12144
 4020fc8:	00001106 	br	4021010 <main+0x214>
       	   	   break;}
       	   case 'r': {
        	   current_focus += manual_focus_step;
 4020fcc:	80800284 	addi	r2,r16,10
 4020fd0:	1021883a 	mov	r16,r2
 4020fd4:	00c0ffc4 	movi	r3,1023
 4020fd8:	10bfffcc 	andi	r2,r2,65535
 4020fdc:	1880062e 	bgeu	r3,r2,4020ff8 <main+0x1fc>
 4020fe0:	1821883a 	mov	r16,r3
 4020fe4:	00000406 	br	4020ff8 <main+0x1fc>
        	   if(current_focus >1023) current_focus = 1023;
        	   OV8865_FOCUS_Move_to(current_focus);
        	   printf("\nFocus = %x ",current_focus);
       	   	   break;}
       	   case 'f': {
        	   if(current_focus > manual_focus_step) current_focus -= manual_focus_step;
 4020fe8:	80bfffcc 	andi	r2,r16,65535
 4020fec:	00c00284 	movi	r3,10
 4020ff0:	1880012e 	bgeu	r3,r2,4020ff8 <main+0x1fc>
 4020ff4:	843ffd84 	addi	r16,r16,-10
        	   OV8865_FOCUS_Move_to(current_focus);
 4020ff8:	84bfffcc 	andi	r18,r16,65535
 4020ffc:	9009883a 	mov	r4,r18
 4021000:	402124c0 	call	402124c <OV8865_FOCUS_Move_to>
        	   printf("\nFocus = %x ",current_focus);
 4021004:	010100b4 	movhi	r4,1026
 4021008:	900b883a 	mov	r5,r18
 402100c:	210bdf04 	addi	r4,r4,12156
 4021010:	4021d700 	call	4021d70 <printf>





	   usleep(1000);
 4021014:	0100fa04 	movi	r4,1000
 4021018:	40229880 	call	4022988 <usleep>

   };
 402101c:	003fb606 	br	4020ef8 <__alt_data_end+0xfffe0ef8>

04021020 <nSWAP16>:
	//y =  (((x) >> 8) & 0xff) | (((x) & 0xff) << 8);

//	y = x;
	y = (x >> 8) & 0x00ff;
	y |= (x << 8) & 0xff00;
	return y;
 4021020:	2004923a 	slli	r2,r4,8
 4021024:	213fffcc 	andi	r4,r4,65535
 4021028:	2008d23a 	srli	r4,r4,8
}
 402102c:	1104b03a 	or	r2,r2,r4
 4021030:	f800283a 	ret

04021034 <MipiBridgeRegWrite>:


void MipiBridgeRegWrite(alt_u16 Addr, alt_u16 Value){
 4021034:	defffd04 	addi	sp,sp,-12
	const alt_u8 device_address = MIPI_BRIDGE_I2C_ADDR;
	OC_I2CL_Write(I2C_OPENCORES_MIPI_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 4021038:	21bfffcc 	andi	r6,r4,65535
 402103c:	00800084 	movi	r2,2
 4021040:	01010134 	movhi	r4,1028
	y |= (x << 8) & 0xff00;
	return y;
}


void MipiBridgeRegWrite(alt_u16 Addr, alt_u16 Value){
 4021044:	d940010d 	sth	r5,4(sp)
	const alt_u8 device_address = MIPI_BRIDGE_I2C_ADDR;
	OC_I2CL_Write(I2C_OPENCORES_MIPI_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 4021048:	d8800015 	stw	r2,0(sp)
 402104c:	d9c00104 	addi	r7,sp,4
 4021050:	01400704 	movi	r5,28
 4021054:	21042804 	addi	r4,r4,4256
	y |= (x << 8) & 0xff00;
	return y;
}


void MipiBridgeRegWrite(alt_u16 Addr, alt_u16 Value){
 4021058:	dfc00215 	stw	ra,8(sp)
	const alt_u8 device_address = MIPI_BRIDGE_I2C_ADDR;
	OC_I2CL_Write(I2C_OPENCORES_MIPI_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 402105c:	40205b00 	call	40205b0 <OC_I2CL_Write>
}
 4021060:	dfc00217 	ldw	ra,8(sp)
 4021064:	dec00304 	addi	sp,sp,12
 4021068:	f800283a 	ret

0402106c <MipiBridgeRegRead>:

alt_u16 MipiBridgeRegRead(alt_u16 Addr){
 402106c:	defffd04 	addi	sp,sp,-12
	alt_u16 Value,tValue;
	const alt_u8 device_address = MIPI_BRIDGE_I2C_ADDR;

	OC_I2CL_Read(I2C_OPENCORES_MIPI_BASE,device_address, Addr,(alt_u8 *)&Value,sizeof(Value));
 4021070:	21bfffcc 	andi	r6,r4,65535
 4021074:	00800084 	movi	r2,2
 4021078:	01010134 	movhi	r4,1028
 402107c:	d8800015 	stw	r2,0(sp)
 4021080:	d9c00104 	addi	r7,sp,4
 4021084:	01400704 	movi	r5,28
 4021088:	21042804 	addi	r4,r4,4256
void MipiBridgeRegWrite(alt_u16 Addr, alt_u16 Value){
	const alt_u8 device_address = MIPI_BRIDGE_I2C_ADDR;
	OC_I2CL_Write(I2C_OPENCORES_MIPI_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
}

alt_u16 MipiBridgeRegRead(alt_u16 Addr){
 402108c:	dfc00215 	stw	ra,8(sp)
	alt_u16 Value,tValue;
	const alt_u8 device_address = MIPI_BRIDGE_I2C_ADDR;

	OC_I2CL_Read(I2C_OPENCORES_MIPI_BASE,device_address, Addr,(alt_u8 *)&Value,sizeof(Value));
 4021090:	40206e40 	call	40206e4 <OC_I2CL_Read>

	tValue = nSWAP16(Value);

	return (tValue);
 4021094:	d8c0010b 	ldhu	r3,4(sp)
 4021098:	1804923a 	slli	r2,r3,8
 402109c:	1806d23a 	srli	r3,r3,8
}
 40210a0:	10c4b03a 	or	r2,r2,r3
 40210a4:	dfc00217 	ldw	ra,8(sp)
 40210a8:	dec00304 	addi	sp,sp,12
 40210ac:	f800283a 	ret

040210b0 <MipiBridgeInit>:
void MipiBridgeInit(void){

	alt_u16 data;
    int i, num;

	printf("\nStart MipiBridgeInit!\n");
 40210b0:	010100b4 	movhi	r4,1026
}




void MipiBridgeInit(void){
 40210b4:	defffa04 	addi	sp,sp,-24

	alt_u16 data;
    int i, num;

	printf("\nStart MipiBridgeInit!\n");
 40210b8:	210be304 	addi	r4,r4,12172
}




void MipiBridgeInit(void){
 40210bc:	dfc00515 	stw	ra,20(sp)
 40210c0:	dd000415 	stw	r20,16(sp)
 40210c4:	dcc00315 	stw	r19,12(sp)
 40210c8:	dc800215 	stw	r18,8(sp)
 40210cc:	dc400115 	stw	r17,4(sp)
 40210d0:	dc000015 	stw	r16,0(sp)

	alt_u16 data;
    int i, num;

	printf("\nStart MipiBridgeInit!\n");
 40210d4:	4021e600 	call	4021e60 <puts>

	data = MipiBridgeRegRead(0x0000); // read chip and revision id;
 40210d8:	0009883a 	mov	r4,zero
 40210dc:	402106c0 	call	402106c <MipiBridgeRegRead>

	printf("Chip and Revision ID is 0x%04xh(expected: 0x4401);\n",data);
 40210e0:	010100b4 	movhi	r4,1026
 40210e4:	040100b4 	movhi	r16,1026
 40210e8:	117fffcc 	andi	r5,r2,65535
 40210ec:	210be904 	addi	r4,r4,12196
 40210f0:	840bfc04 	addi	r16,r16,12272
 40210f4:	4021d700 	call	4021d70 <printf>
 40210f8:	0023883a 	mov	r17,zero


    num = sizeof(MipiBridgeReg)/sizeof(MipiBridgeReg[0]);

    for(i=0;i<num;i++){
   	 if (MipiBridgeReg[i].Addr == 0xFFFF)   usleep(MipiBridgeReg[i].Data*1000);
 40210fc:	84ffff84 	addi	r19,r16,-2
 4021100:	053fffd4 	movui	r20,65535
	printf("Chip and Revision ID is 0x%04xh(expected: 0x4401);\n",data);


    num = sizeof(MipiBridgeReg)/sizeof(MipiBridgeReg[0]);

    for(i=0;i<num;i++){
 4021104:	04800d04 	movi	r18,52
   	 if (MipiBridgeReg[i].Addr == 0xFFFF)   usleep(MipiBridgeReg[i].Data*1000);
 4021108:	8cc5883a 	add	r2,r17,r19
 402110c:	1100000b 	ldhu	r4,0(r2)
 4021110:	2500041e 	bne	r4,r20,4021124 <MipiBridgeInit+0x74>
 4021114:	8100000b 	ldhu	r4,0(r16)
 4021118:	2100fa24 	muli	r4,r4,1000
 402111c:	40229880 	call	4022988 <usleep>
 4021120:	00000206 	br	402112c <MipiBridgeInit+0x7c>
        else MipiBridgeRegWrite(MipiBridgeReg[i].Addr,  MipiBridgeReg[i].Data);
 4021124:	8140000b 	ldhu	r5,0(r16)
 4021128:	40210340 	call	4021034 <MipiBridgeRegWrite>
 402112c:	8c400104 	addi	r17,r17,4
 4021130:	84000104 	addi	r16,r16,4
	printf("Chip and Revision ID is 0x%04xh(expected: 0x4401);\n",data);


    num = sizeof(MipiBridgeReg)/sizeof(MipiBridgeReg[0]);

    for(i=0;i<num;i++){
 4021134:	8cbff41e 	bne	r17,r18,4021108 <__alt_data_end+0xfffe1108>
//     MipiBridgeRegWrite(0x005A,((cap<<6) + (HsRxRs<<4) + ClkDly_data));
//     MipiBridgeRegWrite(0x005C,((cap<<6) + (HsRxRs<<4) + ClkDly_data));
//     MipiBridgeRegWrite(0x005E,((cap<<6) + (HsRxRs<<4) + ClkDly_data));
//

    printf("End MipiBridgeInit!\n\n");
 4021138:	010100b4 	movhi	r4,1026
 402113c:	210bf604 	addi	r4,r4,12248

}
 4021140:	dfc00517 	ldw	ra,20(sp)
 4021144:	dd000417 	ldw	r20,16(sp)
 4021148:	dcc00317 	ldw	r19,12(sp)
 402114c:	dc800217 	ldw	r18,8(sp)
 4021150:	dc400117 	ldw	r17,4(sp)
 4021154:	dc000017 	ldw	r16,0(sp)
 4021158:	dec00604 	addi	sp,sp,24
//     MipiBridgeRegWrite(0x005A,((cap<<6) + (HsRxRs<<4) + ClkDly_data));
//     MipiBridgeRegWrite(0x005C,((cap<<6) + (HsRxRs<<4) + ClkDly_data));
//     MipiBridgeRegWrite(0x005E,((cap<<6) + (HsRxRs<<4) + ClkDly_data));
//

    printf("End MipiBridgeInit!\n\n");
 402115c:	4021e601 	jmpi	4021e60 <puts>

04021160 <OV8865_read_cmos_sensor_8>:
   };




alt_u8 OV8865_read_cmos_sensor_8(alt_u16 Addr){
 4021160:	defffd04 	addi	sp,sp,-12
	const alt_u8 device_address = MIPI_I2C_ADDR;
	alt_u8 Value;

	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Read(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 4021164:	21bfffcc 	andi	r6,r4,65535
 4021168:	00800044 	movi	r2,1
 402116c:	01010134 	movhi	r4,1028
 4021170:	d8800015 	stw	r2,0(sp)
 4021174:	d9c00104 	addi	r7,sp,4
 4021178:	01401b04 	movi	r5,108
 402117c:	21042004 	addi	r4,r4,4224
   };




alt_u8 OV8865_read_cmos_sensor_8(alt_u16 Addr){
 4021180:	dfc00215 	stw	ra,8(sp)
	const alt_u8 device_address = MIPI_I2C_ADDR;
	alt_u8 Value;

	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Read(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 4021184:	40206e40 	call	40206e4 <OC_I2CL_Read>

	return (Value);
}
 4021188:	d8800103 	ldbu	r2,4(sp)
 402118c:	dfc00217 	ldw	ra,8(sp)
 4021190:	dec00304 	addi	sp,sp,12
 4021194:	f800283a 	ret

04021198 <OV8865_write_cmos_sensor_8>:


void OV8865_write_cmos_sensor_8(alt_u16 Addr, alt_u8 Value){
 4021198:	defffd04 	addi	sp,sp,-12
	const alt_u8 device_address = MIPI_I2C_ADDR;
	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 402119c:	21bfffcc 	andi	r6,r4,65535
 40211a0:	00800044 	movi	r2,1
 40211a4:	01010134 	movhi	r4,1028

	return (Value);
}


void OV8865_write_cmos_sensor_8(alt_u16 Addr, alt_u8 Value){
 40211a8:	d9400105 	stb	r5,4(sp)
	const alt_u8 device_address = MIPI_I2C_ADDR;
	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 40211ac:	d8800015 	stw	r2,0(sp)
 40211b0:	d9c00104 	addi	r7,sp,4
 40211b4:	01401b04 	movi	r5,108
 40211b8:	21042004 	addi	r4,r4,4224

	return (Value);
}


void OV8865_write_cmos_sensor_8(alt_u16 Addr, alt_u8 Value){
 40211bc:	dfc00215 	stw	ra,8(sp)
	const alt_u8 device_address = MIPI_I2C_ADDR;
	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
 40211c0:	40205b00 	call	40205b0 <OC_I2CL_Write>
}
 40211c4:	dfc00217 	ldw	ra,8(sp)
 40211c8:	dec00304 	addi	sp,sp,12
 40211cc:	f800283a 	ret

040211d0 <OV8865_write_AF>:


void OV8865_write_AF(alt_u8 msb, alt_u8 lsb){
 40211d0:	defffd04 	addi	sp,sp,-12
	// VCM149C
	const alt_u8 device_address = MIPI_AF_I2C_ADDR;
	OC_I2C_Write(I2C_OPENCORES_CAMERA_BASE, device_address, msb, (alt_u8 *)&lsb, sizeof(lsb));
 40211d4:	21803fcc 	andi	r6,r4,255
 40211d8:	00800044 	movi	r2,1
 40211dc:	01010134 	movhi	r4,1028
	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
}


void OV8865_write_AF(alt_u8 msb, alt_u8 lsb){
 40211e0:	d9400105 	stb	r5,4(sp)
	// VCM149C
	const alt_u8 device_address = MIPI_AF_I2C_ADDR;
	OC_I2C_Write(I2C_OPENCORES_CAMERA_BASE, device_address, msb, (alt_u8 *)&lsb, sizeof(lsb));
 40211e4:	d8800015 	stw	r2,0(sp)
 40211e8:	d9c00104 	addi	r7,sp,4
 40211ec:	01400604 	movi	r5,24
 40211f0:	21042004 	addi	r4,r4,4224
	//OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, SWAP16(Addr), (alt_u8 *)&Value, sizeof(Value));
	OC_I2CL_Write(I2C_OPENCORES_CAMERA_BASE, device_address, Addr, (alt_u8 *)&Value, sizeof(Value));
}


void OV8865_write_AF(alt_u8 msb, alt_u8 lsb){
 40211f4:	dfc00215 	stw	ra,8(sp)
	// VCM149C
	const alt_u8 device_address = MIPI_AF_I2C_ADDR;
	OC_I2C_Write(I2C_OPENCORES_CAMERA_BASE, device_address, msb, (alt_u8 *)&lsb, sizeof(lsb));
 40211f8:	40202200 	call	4020220 <OC_I2C_Write>
}
 40211fc:	dfc00217 	ldw	ra,8(sp)
 4021200:	dec00304 	addi	sp,sp,12
 4021204:	f800283a 	ret

04021208 <OV8865_read_AF>:

void OV8865_read_AF(void){
 4021208:	defffe04 	addi	sp,sp,-8
	// VCM149C
	const alt_u8 device_address = MIPI_AF_I2C_ADDR;
	alt_u8 szData8[2];
	bool bSuccess;

		bSuccess = OC_I2C_Read_Continue(I2C_OPENCORES_CAMERA_BASE, device_address, szData8, sizeof(szData8));
 402120c:	01010134 	movhi	r4,1028
 4021210:	01c00084 	movi	r7,2
 4021214:	d80d883a 	mov	r6,sp
 4021218:	01400604 	movi	r5,24
 402121c:	21042004 	addi	r4,r4,4224
	// VCM149C
	const alt_u8 device_address = MIPI_AF_I2C_ADDR;
	OC_I2C_Write(I2C_OPENCORES_CAMERA_BASE, device_address, msb, (alt_u8 *)&lsb, sizeof(lsb));
}

void OV8865_read_AF(void){
 4021220:	dfc00115 	stw	ra,4(sp)
	// VCM149C
	const alt_u8 device_address = MIPI_AF_I2C_ADDR;
	alt_u8 szData8[2];
	bool bSuccess;

		bSuccess = OC_I2C_Read_Continue(I2C_OPENCORES_CAMERA_BASE, device_address, szData8, sizeof(szData8));
 4021224:	40204bc0 	call	40204bc <OC_I2C_Read_Continue>
		if (bSuccess)
 4021228:	10000526 	beq	r2,zero,4021240 <OV8865_read_AF+0x38>
			printf("Read MSB=%xh, LSB=%xh\r\n", szData8[0], szData8[1]);
 402122c:	d9800043 	ldbu	r6,1(sp)
 4021230:	d9400003 	ldbu	r5,0(sp)
 4021234:	010100b4 	movhi	r4,1026
 4021238:	210c0904 	addi	r4,r4,12324
 402123c:	4021d700 	call	4021d70 <printf>
}
 4021240:	dfc00117 	ldw	ra,4(sp)
 4021244:	dec00204 	addi	sp,sp,8
 4021248:	f800283a 	ret

0402124c <OV8865_FOCUS_Move_to>:

void OV8865_FOCUS_Move_to(alt_u16 a_u2MovePosition)
{
 402124c:	defffe04 	addi	sp,sp,-8
 4021250:	dc000015 	stw	r16,0(sp)
 4021254:	dfc00115 	stw	ra,4(sp)
 4021258:	2021883a 	mov	r16,r4
 402125c:	0080ffc4 	movi	r2,1023
 4021260:	213fffcc 	andi	r4,r4,65535
 4021264:	1100012e 	bgeu	r2,r4,402126c <OV8865_FOCUS_Move_to+0x20>
 4021268:	1021883a 	mov	r16,r2
  if (a_u2MovePosition > 1023)   {a_u2MovePosition = 1023;}
  if (a_u2MovePosition < 0)     {a_u2MovePosition = 0;}
  int bSuccess;

  Focus_Released(); // waiting for VCM release I2C bus
 402126c:	40209580 	call	4020958 <Focus_Released>

	bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4021270:	018001b4 	movhi	r6,6
 4021274:	0140bef4 	movhi	r5,763
 4021278:	01010134 	movhi	r4,1028
 402127c:	3186a004 	addi	r6,r6,6784
 4021280:	297c2004 	addi	r5,r5,-3968
 4021284:	21042004 	addi	r4,r4,4224
 4021288:	40200a00 	call	40200a0 <oc_i2c_init_ex>
	if (!bSuccess)
 402128c:	1000031e 	bne	r2,zero,402129c <OV8865_FOCUS_Move_to+0x50>
		printf("failed to init MIPI- Camera i2c\r\n");
 4021290:	010100b4 	movhi	r4,1026
 4021294:	210c0f04 	addi	r4,r4,12348
 4021298:	4021e600 	call	4021e60 <puts>
  alt_u8 msb,lsb;
  msb = (a_u2MovePosition >> 4)&0x00FF;
  lsb = (a_u2MovePosition << 4 )&0x00F0;
  lsb += 0x06;
//	printf("Write MSB=%xh, LSB=%xh\r\n", msb, lsb);
	OV8865_write_AF(msb, lsb+0x6);
 402129c:	813fffcc 	andi	r4,r16,65535
 40212a0:	200a913a 	slli	r5,r4,4
 40212a4:	2008d13a 	srli	r4,r4,4
 40212a8:	29400304 	addi	r5,r5,12
 40212ac:	29403fcc 	andi	r5,r5,255
 40212b0:	40211d00 	call	40211d0 <OV8865_write_AF>
	usleep(1000);
 40212b4:	0100fa04 	movi	r4,1000
 40212b8:	40229880 	call	4022988 <usleep>
//	OV8865_read_AF();

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);  // Release I2C bus , due to two I2C master shared!
 40212bc:	01010134 	movhi	r4,1028
 40212c0:	21042004 	addi	r4,r4,4224

}
 40212c4:	dfc00117 	ldw	ra,4(sp)
 40212c8:	dc000017 	ldw	r16,0(sp)
 40212cc:	dec00204 	addi	sp,sp,8
//	printf("Write MSB=%xh, LSB=%xh\r\n", msb, lsb);
	OV8865_write_AF(msb, lsb+0x6);
	usleep(1000);
//	OV8865_read_AF();

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);  // Release I2C bus , due to two I2C master shared!
 40212d0:	40201441 	jmpi	4020144 <oc_i2c_uninit>

040212d4 <OV8865SetExposure>:

}

void OV8865SetExposure(alt_u32 exposure){
 40212d4:	defffe04 	addi	sp,sp,-8
 40212d8:	dc000015 	stw	r16,0(sp)
 40212dc:	dfc00115 	stw	ra,4(sp)
 40212e0:	2021883a 	mov	r16,r4

	Focus_Released(); // waiting for VCM release I2C bus
 40212e4:	40209580 	call	4020958 <Focus_Released>

	int bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
 40212e8:	018001b4 	movhi	r6,6
 40212ec:	0140bef4 	movhi	r5,763
 40212f0:	01010134 	movhi	r4,1028
 40212f4:	3186a004 	addi	r6,r6,6784
 40212f8:	297c2004 	addi	r5,r5,-3968
 40212fc:	21042004 	addi	r4,r4,4224
 4021300:	40200a00 	call	40200a0 <oc_i2c_init_ex>
	if (!bSuccess)
 4021304:	1000031e 	bne	r2,zero,4021314 <OV8865SetExposure+0x40>
		printf("failed to init MIPI- Camera i2c\r\n");
 4021308:	010100b4 	movhi	r4,1026
 402130c:	210c0f04 	addi	r4,r4,12348
 4021310:	4021e600 	call	4021e60 <puts>

	if (exposure > 0xFFFFF) exposure = 0xFFFFF;
 4021314:	00800434 	movhi	r2,16
 4021318:	10bfffc4 	addi	r2,r2,-1
 402131c:	14000436 	bltu	r2,r16,4021330 <OV8865SetExposure+0x5c>
	if (exposure < 0x20) exposure = 0x20;
 4021320:	008007c4 	movi	r2,31
 4021324:	14000336 	bltu	r2,r16,4021334 <OV8865SetExposure+0x60>
 4021328:	04000804 	movi	r16,32
 402132c:	00000106 	br	4021334 <OV8865SetExposure+0x60>

	int bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
	if (!bSuccess)
		printf("failed to init MIPI- Camera i2c\r\n");

	if (exposure > 0xFFFFF) exposure = 0xFFFFF;
 4021330:	1021883a 	mov	r16,r2
	if (exposure < 0x20) exposure = 0x20;

	OV8865_write_cmos_sensor_8(0x3500, (exposure >> 16) & 0x0F);
 4021334:	800ad43a 	srli	r5,r16,16
 4021338:	010d4004 	movi	r4,13568
 402133c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
	OV8865_write_cmos_sensor_8(0x3501, (exposure >> 8) & 0xFF);
 4021340:	800ad23a 	srli	r5,r16,8
 4021344:	010d4044 	movi	r4,13569
 4021348:	29403fcc 	andi	r5,r5,255
 402134c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
	OV8865_write_cmos_sensor_8(0x3502, exposure & 0xFF);
 4021350:	81403fcc 	andi	r5,r16,255
 4021354:	010d4084 	movi	r4,13570
 4021358:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>


	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 402135c:	01010134 	movhi	r4,1028
 4021360:	21042004 	addi	r4,r4,4224
}
 4021364:	dfc00117 	ldw	ra,4(sp)
 4021368:	dc000017 	ldw	r16,0(sp)
 402136c:	dec00204 	addi	sp,sp,8
	OV8865_write_cmos_sensor_8(0x3500, (exposure >> 16) & 0x0F);
	OV8865_write_cmos_sensor_8(0x3501, (exposure >> 8) & 0xFF);
	OV8865_write_cmos_sensor_8(0x3502, exposure & 0xFF);


	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 4021370:	40201441 	jmpi	4020144 <oc_i2c_uninit>

04021374 <OV8865SetGain>:
}

void OV8865SetGain(alt_u16 gain){
 4021374:	defffd04 	addi	sp,sp,-12
 4021378:	dc400115 	stw	r17,4(sp)
 402137c:	dc000015 	stw	r16,0(sp)
 4021380:	dfc00215 	stw	ra,8(sp)
 4021384:	2021883a 	mov	r16,r4
 4021388:	2023883a 	mov	r17,r4

	Focus_Released(); // waiting for VCM release I2C bus
 402138c:	40209580 	call	4020958 <Focus_Released>

	int bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4021390:	018001b4 	movhi	r6,6
 4021394:	0140bef4 	movhi	r5,763
 4021398:	01010134 	movhi	r4,1028
 402139c:	3186a004 	addi	r6,r6,6784
 40213a0:	297c2004 	addi	r5,r5,-3968
 40213a4:	21042004 	addi	r4,r4,4224
 40213a8:	40200a00 	call	40200a0 <oc_i2c_init_ex>
	if (!bSuccess)
 40213ac:	1000031e 	bne	r2,zero,40213bc <OV8865SetGain+0x48>
		printf("failed to init MIPI- Camera i2c\r\n");
 40213b0:	010100b4 	movhi	r4,1026
 40213b4:	210c0f04 	addi	r4,r4,12348
 40213b8:	4021e600 	call	4021e60 <puts>

	if (gain > 0x7FF) gain = 0x7FF;
 40213bc:	843fffcc 	andi	r16,r16,65535
 40213c0:	0081ffc4 	movi	r2,2047
 40213c4:	14000436 	bltu	r2,r16,40213d8 <OV8865SetGain+0x64>
	if (gain < 0x080) gain = 0x080;
 40213c8:	00801fc4 	movi	r2,127
 40213cc:	14000336 	bltu	r2,r16,40213dc <OV8865SetGain+0x68>
 40213d0:	04402004 	movi	r17,128
 40213d4:	00000106 	br	40213dc <OV8865SetGain+0x68>

	int bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
	if (!bSuccess)
		printf("failed to init MIPI- Camera i2c\r\n");

	if (gain > 0x7FF) gain = 0x7FF;
 40213d8:	1023883a 	mov	r17,r2
	if (gain < 0x080) gain = 0x080;

	OV8865_write_cmos_sensor_8(0x3508, (gain >> 8) & 0x0F);
 40213dc:	897fffcc 	andi	r5,r17,65535
 40213e0:	280ad23a 	srli	r5,r5,8
 40213e4:	010d4204 	movi	r4,13576
 40213e8:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
	OV8865_write_cmos_sensor_8(0x3509, gain & 0xFF);
 40213ec:	89403fcc 	andi	r5,r17,255
 40213f0:	010d4244 	movi	r4,13577
 40213f4:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>


	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 40213f8:	01010134 	movhi	r4,1028
 40213fc:	21042004 	addi	r4,r4,4224
}
 4021400:	dfc00217 	ldw	ra,8(sp)
 4021404:	dc400117 	ldw	r17,4(sp)
 4021408:	dc000017 	ldw	r16,0(sp)
 402140c:	dec00304 	addi	sp,sp,12

	OV8865_write_cmos_sensor_8(0x3508, (gain >> 8) & 0x0F);
	OV8865_write_cmos_sensor_8(0x3509, gain & 0xFF);


	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 4021410:	40201441 	jmpi	4020144 <oc_i2c_uninit>

04021414 <OV8865ReadExposure>:
}

alt_u32 OV8865ReadExposure(){
 4021414:	defffe04 	addi	sp,sp,-8
 4021418:	dfc00115 	stw	ra,4(sp)
 402141c:	dc000015 	stw	r16,0(sp)

	alt_u32 exposure;

	Focus_Released(); // waiting for VCM release I2C bus
 4021420:	40209580 	call	4020958 <Focus_Released>

	int bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4021424:	018001b4 	movhi	r6,6
 4021428:	0140bef4 	movhi	r5,763
 402142c:	01010134 	movhi	r4,1028
 4021430:	3186a004 	addi	r6,r6,6784
 4021434:	297c2004 	addi	r5,r5,-3968
 4021438:	21042004 	addi	r4,r4,4224
 402143c:	40200a00 	call	40200a0 <oc_i2c_init_ex>
	if (!bSuccess)
 4021440:	1000031e 	bne	r2,zero,4021450 <OV8865ReadExposure+0x3c>
		printf("failed to init MIPI- Camera i2c\r\n");
 4021444:	010100b4 	movhi	r4,1026
 4021448:	210c0f04 	addi	r4,r4,12348
 402144c:	4021e600 	call	4021e60 <puts>

	exposure = OV8865_read_cmos_sensor_8(0x3500);
 4021450:	010d4004 	movi	r4,13568
 4021454:	40211600 	call	4021160 <OV8865_read_cmos_sensor_8>
	exposure = (exposure <<8) | OV8865_read_cmos_sensor_8(0x3501);
 4021458:	10803fcc 	andi	r2,r2,255
 402145c:	1020923a 	slli	r16,r2,8
 4021460:	010d4044 	movi	r4,13569
 4021464:	40211600 	call	4021160 <OV8865_read_cmos_sensor_8>
	exposure = (exposure <<8) | OV8865_read_cmos_sensor_8(0x3502);
 4021468:	10803fcc 	andi	r2,r2,255
 402146c:	1420b03a 	or	r16,r2,r16
 4021470:	010d4084 	movi	r4,13570
 4021474:	40211600 	call	4021160 <OV8865_read_cmos_sensor_8>
 4021478:	8020923a 	slli	r16,r16,8

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 402147c:	01010134 	movhi	r4,1028
	if (!bSuccess)
		printf("failed to init MIPI- Camera i2c\r\n");

	exposure = OV8865_read_cmos_sensor_8(0x3500);
	exposure = (exposure <<8) | OV8865_read_cmos_sensor_8(0x3501);
	exposure = (exposure <<8) | OV8865_read_cmos_sensor_8(0x3502);
 4021480:	10803fcc 	andi	r2,r2,255

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 4021484:	21042004 	addi	r4,r4,4224
	if (!bSuccess)
		printf("failed to init MIPI- Camera i2c\r\n");

	exposure = OV8865_read_cmos_sensor_8(0x3500);
	exposure = (exposure <<8) | OV8865_read_cmos_sensor_8(0x3501);
	exposure = (exposure <<8) | OV8865_read_cmos_sensor_8(0x3502);
 4021488:	1420b03a 	or	r16,r2,r16

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);
 402148c:	40201440 	call	4020144 <oc_i2c_uninit>

	return exposure;
}
 4021490:	8005883a 	mov	r2,r16
 4021494:	dfc00117 	ldw	ra,4(sp)
 4021498:	dc000017 	ldw	r16,0(sp)
 402149c:	dec00204 	addi	sp,sp,8
 40214a0:	f800283a 	ret

040214a4 <MIPI_BIN_LEVEL>:




//ZOOM
void MIPI_BIN_LEVEL(alt_u8 level){
 40214a4:	defffc04 	addi	sp,sp,-16
 40214a8:	dc000015 	stw	r16,0(sp)
 40214ac:	dfc00315 	stw	ra,12(sp)
 40214b0:	2021883a 	mov	r16,r4
 40214b4:	dc800215 	stw	r18,8(sp)
 40214b8:	dc400115 	stw	r17,4(sp)
	if(level <= 1) level = 1;
 40214bc:	21003fcc 	andi	r4,r4,255
 40214c0:	00800044 	movi	r2,1
 40214c4:	1100042e 	bgeu	r2,r4,40214d8 <MIPI_BIN_LEVEL+0x34>
	if(level >= 3) level = 3;
 40214c8:	00800084 	movi	r2,2
 40214cc:	20800326 	beq	r4,r2,40214dc <MIPI_BIN_LEVEL+0x38>
 40214d0:	040000c4 	movi	r16,3
 40214d4:	00000106 	br	40214dc <MIPI_BIN_LEVEL+0x38>



//ZOOM
void MIPI_BIN_LEVEL(alt_u8 level){
	if(level <= 1) level = 1;
 40214d8:	1021883a 	mov	r16,r2
	if(level >= 3) level = 3;

	  Focus_Released(); // waiting for VCM release I2C bus
 40214dc:	40209580 	call	4020958 <Focus_Released>

	  int bSuccess;
		bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
 40214e0:	018001b4 	movhi	r6,6
 40214e4:	0140bef4 	movhi	r5,763
 40214e8:	01010134 	movhi	r4,1028
 40214ec:	3186a004 	addi	r6,r6,6784
 40214f0:	297c2004 	addi	r5,r5,-3968
 40214f4:	21042004 	addi	r4,r4,4224
 40214f8:	40200a00 	call	40200a0 <oc_i2c_init_ex>
		if (!bSuccess)
 40214fc:	1000031e 	bne	r2,zero,402150c <MIPI_BIN_LEVEL+0x68>
			printf("failed to init MIPI- Camera i2c\r\n");
 4021500:	010100b4 	movhi	r4,1026
 4021504:	210c0f04 	addi	r4,r4,12348
 4021508:	4021e600 	call	4021e60 <puts>


	OV8865_write_cmos_sensor_8(0x0100, 0x00);
 402150c:	000b883a 	mov	r5,zero
 4021510:	01004004 	movi	r4,256

	if(level == 1){
 4021514:	84003fcc 	andi	r16,r16,255
 4021518:	04400044 	movi	r17,1
		bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
		if (!bSuccess)
			printf("failed to init MIPI- Camera i2c\r\n");


	OV8865_write_cmos_sensor_8(0x0100, 0x00);
 402151c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>

	if(level == 1){
 4021520:	8440111e 	bne	r16,r17,4021568 <MIPI_BIN_LEVEL+0xc4>

		OV8865_write_cmos_sensor_8(0x3814, 0x01);
 4021524:	800b883a 	mov	r5,r16
 4021528:	010e0504 	movi	r4,14356
 402152c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x3815, 0x01);
 4021530:	800b883a 	mov	r5,r16
 4021534:	010e0544 	movi	r4,14357
 4021538:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x382a, 0x01);
 402153c:	800b883a 	mov	r5,r16
 4021540:	010e0a84 	movi	r4,14378
 4021544:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x382b, 0x01);
 4021548:	800b883a 	mov	r5,r16
 402154c:	010e0ac4 	movi	r4,14379
 4021550:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>

		OV8865_write_cmos_sensor_8(0x3830, 8);
 4021554:	01400204 	movi	r5,8
 4021558:	010e0c04 	movi	r4,14384
 402155c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x3836, 2);
 4021560:	01400084 	movi	r5,2
 4021564:	00002306 	br	40215f4 <MIPI_BIN_LEVEL+0x150>
	}
	else if(level == 2){
 4021568:	04800084 	movi	r18,2
 402156c:	8480111e 	bne	r16,r18,40215b4 <MIPI_BIN_LEVEL+0x110>

		OV8865_write_cmos_sensor_8(0x3814, 0x03);
 4021570:	014000c4 	movi	r5,3
 4021574:	010e0504 	movi	r4,14356
 4021578:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x3815, 0x01);
 402157c:	880b883a 	mov	r5,r17
 4021580:	010e0544 	movi	r4,14357
 4021584:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x382a, 0x03);
 4021588:	014000c4 	movi	r5,3
 402158c:	010e0a84 	movi	r4,14378
 4021590:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x382b, 0x01);
 4021594:	880b883a 	mov	r5,r17
 4021598:	010e0ac4 	movi	r4,14379
 402159c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>

		OV8865_write_cmos_sensor_8(0x3830, 4);
 40215a0:	01400104 	movi	r5,4
 40215a4:	010e0c04 	movi	r4,14384
 40215a8:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x3836, 1);
 40215ac:	880b883a 	mov	r5,r17
 40215b0:	00001006 	br	40215f4 <MIPI_BIN_LEVEL+0x150>

	}
	else if(level == 3){

		OV8865_write_cmos_sensor_8(0x3814, 0x07);
 40215b4:	014001c4 	movi	r5,7
 40215b8:	010e0504 	movi	r4,14356
 40215bc:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x3815, 0x01);
 40215c0:	880b883a 	mov	r5,r17
 40215c4:	010e0544 	movi	r4,14357
 40215c8:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x382a, 0x07);
 40215cc:	014001c4 	movi	r5,7
 40215d0:	010e0a84 	movi	r4,14378
 40215d4:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x382b, 0x01);
 40215d8:	880b883a 	mov	r5,r17
 40215dc:	010e0ac4 	movi	r4,14379
 40215e0:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>

		OV8865_write_cmos_sensor_8(0x3830, 8);
 40215e4:	01400204 	movi	r5,8
 40215e8:	010e0c04 	movi	r4,14384
 40215ec:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
		OV8865_write_cmos_sensor_8(0x3836, 2);
 40215f0:	900b883a 	mov	r5,r18
 40215f4:	010e0d84 	movi	r4,14390
 40215f8:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
	}
    usleep(10000);
 40215fc:	0109c404 	movi	r4,10000
 4021600:	40229880 	call	4022988 <usleep>
	OV8865_write_cmos_sensor_8(0x0100, 0x01);
 4021604:	01400044 	movi	r5,1
 4021608:	01004004 	movi	r4,256
 402160c:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);  // Release I2C bus , due to two I2C master shared!
 4021610:	01010134 	movhi	r4,1028
 4021614:	21042004 	addi	r4,r4,4224

}
 4021618:	dfc00317 	ldw	ra,12(sp)
 402161c:	dc800217 	ldw	r18,8(sp)
 4021620:	dc400117 	ldw	r17,4(sp)
 4021624:	dc000017 	ldw	r16,0(sp)
 4021628:	dec00404 	addi	sp,sp,16
		OV8865_write_cmos_sensor_8(0x3836, 2);
	}
    usleep(10000);
	OV8865_write_cmos_sensor_8(0x0100, 0x01);

	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);  // Release I2C bus , due to two I2C master shared!
 402162c:	40201441 	jmpi	4020144 <oc_i2c_uninit>

04021630 <MipiCameraInit>:
//		OV8865_write_cmos_sensor_8(0x0100, 0x01);
//}


void MipiCameraInit(void)
{
 4021630:	defff904 	addi	sp,sp,-28
 4021634:	dfc00615 	stw	ra,24(sp)
 4021638:	dd400515 	stw	r21,20(sp)
 402163c:	dd000415 	stw	r20,16(sp)
 4021640:	dcc00315 	stw	r19,12(sp)
 4021644:	dc800215 	stw	r18,8(sp)
 4021648:	dc400115 	stw	r17,4(sp)
 402164c:	dc000015 	stw	r16,0(sp)

    int i, num;
    int bSuccess;

    Focus_Released(); // waiting for VCM release I2C bus
 4021650:	40209580 	call	4020958 <Focus_Released>


		bSuccess = oc_i2c_init_ex(I2C_OPENCORES_CAMERA_BASE, 50*1000*1000,400*1000); //I2C: 400K
 4021654:	018001b4 	movhi	r6,6
 4021658:	0140bef4 	movhi	r5,763
 402165c:	01010134 	movhi	r4,1028
 4021660:	3186a004 	addi	r6,r6,6784
 4021664:	297c2004 	addi	r5,r5,-3968
 4021668:	21042004 	addi	r4,r4,4224
 402166c:	40200a00 	call	40200a0 <oc_i2c_init_ex>
		if (!bSuccess)
 4021670:	1000031e 	bne	r2,zero,4021680 <MipiCameraInit+0x50>
			printf("failed to init MIPI- Camera i2c\r\n");
 4021674:	010100b4 	movhi	r4,1026
 4021678:	210c0f04 	addi	r4,r4,12348
 402167c:	4021e600 	call	4021e60 <puts>
//        usleep(10000);
//    }
//


	 OV8865DB("\nStart MipiCameraInit -OV8865!\r\n");
 4021680:	010100b4 	movhi	r4,1026
 4021684:	210c1804 	addi	r4,r4,12384
 4021688:	4021e600 	call	4021e60 <puts>
	 OV8865DB("Write Read Test!\n");
 402168c:	010100b4 	movhi	r4,1026
 4021690:	210c2004 	addi	r4,r4,12416
 4021694:	4021e600 	call	4021e60 <puts>

	    for(i=0;i<10;i++){
 4021698:	0021883a 	mov	r16,zero
 402169c:	04400284 	movi	r17,10
	       OV8865_write_cmos_sensor_8(0x3809,i);
 40216a0:	800b883a 	mov	r5,r16
 40216a4:	010e0244 	movi	r4,14345
 40216a8:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
	      usleep(100);
 40216ac:	01001904 	movi	r4,100
 40216b0:	40229880 	call	4022988 <usleep>
	        printf("%d (%d)\n",OV8865_read_cmos_sensor_8(0x3809),i);
 40216b4:	010e0244 	movi	r4,14345
 40216b8:	40211600 	call	4021160 <OV8865_read_cmos_sensor_8>
 40216bc:	010100b4 	movhi	r4,1026
 40216c0:	800d883a 	mov	r6,r16
 40216c4:	11403fcc 	andi	r5,r2,255
 40216c8:	210c2504 	addi	r4,r4,12436
 40216cc:	4021d700 	call	4021d70 <printf>
	      usleep(100);
 40216d0:	01001904 	movi	r4,100


	 OV8865DB("\nStart MipiCameraInit -OV8865!\r\n");
	 OV8865DB("Write Read Test!\n");

	    for(i=0;i<10;i++){
 40216d4:	84000044 	addi	r16,r16,1
	       OV8865_write_cmos_sensor_8(0x3809,i);
	      usleep(100);
	        printf("%d (%d)\n",OV8865_read_cmos_sensor_8(0x3809),i);
	      usleep(100);
 40216d8:	40229880 	call	4022988 <usleep>


	 OV8865DB("\nStart MipiCameraInit -OV8865!\r\n");
	 OV8865DB("Write Read Test!\n");

	    for(i=0;i<10;i++){
 40216dc:	847ff01e 	bne	r16,r17,40216a0 <__alt_data_end+0xfffe16a0>
 40216e0:	040100b4 	movhi	r16,1026
 40216e4:	840c3104 	addi	r16,r16,12484
 40216e8:	0023883a 	mov	r17,zero
	      usleep(100);
	    }
	 num = sizeof(MipiCameraReg)/sizeof(MipiCameraReg[0]);
     for(i=0;i<num;i++){

    	 if (MipiCameraReg[i].Type == TIME_DELAY)   usleep(MipiCameraReg[i].Data*100);
 40216ec:	84bfff04 	addi	r18,r16,-4
 40216f0:	04c000c4 	movi	r19,3
    	 else if(MipiCameraReg[i].Type == END_OF_SCRIPT)   break;
 40216f4:	05000104 	movi	r20,4
    	 else if(MipiCameraReg[i].Type == 0x6c)   OV8865_write_cmos_sensor_8(MipiCameraReg[i].Addr, MipiCameraReg[i].Data);
 40216f8:	05401b04 	movi	r21,108
	      usleep(100);
	    }
	 num = sizeof(MipiCameraReg)/sizeof(MipiCameraReg[0]);
     for(i=0;i<num;i++){

    	 if (MipiCameraReg[i].Type == TIME_DELAY)   usleep(MipiCameraReg[i].Data*100);
 40216fc:	8c85883a 	add	r2,r17,r18
 4021700:	10800003 	ldbu	r2,0(r2)
 4021704:	14c0041e 	bne	r2,r19,4021718 <MipiCameraInit+0xe8>
 4021708:	81000003 	ldbu	r4,0(r16)
 402170c:	21001924 	muli	r4,r4,100
 4021710:	40229880 	call	4022988 <usleep>
 4021714:	00001306 	br	4021764 <MipiCameraInit+0x134>
    	 else if(MipiCameraReg[i].Type == END_OF_SCRIPT)   break;
 4021718:	15000e1e 	bne	r2,r20,4021754 <MipiCameraInit+0x124>
    	 else if(MipiCameraReg[i].Type == 0x6c)   OV8865_write_cmos_sensor_8(MipiCameraReg[i].Addr, MipiCameraReg[i].Data);
     }


 	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);  // Release I2C bus , due to two I2C master shared!
 402171c:	01010134 	movhi	r4,1028
 4021720:	21042004 	addi	r4,r4,4224
 4021724:	40201440 	call	4020144 <oc_i2c_uninit>



	 OV8865DB("\nEnd MipiCameraInit! -OV8865!\r\n\n");
 4021728:	010100b4 	movhi	r4,1026
 402172c:	210c2804 	addi	r4,r4,12448

}
 4021730:	dfc00617 	ldw	ra,24(sp)
 4021734:	dd400517 	ldw	r21,20(sp)
 4021738:	dd000417 	ldw	r20,16(sp)
 402173c:	dcc00317 	ldw	r19,12(sp)
 4021740:	dc800217 	ldw	r18,8(sp)
 4021744:	dc400117 	ldw	r17,4(sp)
 4021748:	dc000017 	ldw	r16,0(sp)
 402174c:	dec00704 	addi	sp,sp,28

 	oc_i2c_uninit(I2C_OPENCORES_CAMERA_BASE);  // Release I2C bus , due to two I2C master shared!



	 OV8865DB("\nEnd MipiCameraInit! -OV8865!\r\n\n");
 4021750:	4021e601 	jmpi	4021e60 <puts>
	 num = sizeof(MipiCameraReg)/sizeof(MipiCameraReg[0]);
     for(i=0;i<num;i++){

    	 if (MipiCameraReg[i].Type == TIME_DELAY)   usleep(MipiCameraReg[i].Data*100);
    	 else if(MipiCameraReg[i].Type == END_OF_SCRIPT)   break;
    	 else if(MipiCameraReg[i].Type == 0x6c)   OV8865_write_cmos_sensor_8(MipiCameraReg[i].Addr, MipiCameraReg[i].Data);
 4021754:	1540031e 	bne	r2,r21,4021764 <MipiCameraInit+0x134>
 4021758:	81400003 	ldbu	r5,0(r16)
 402175c:	813fff8b 	ldhu	r4,-2(r16)
 4021760:	40211980 	call	4021198 <OV8865_write_cmos_sensor_8>
 4021764:	8c400184 	addi	r17,r17,6
	      usleep(100);
	        printf("%d (%d)\n",OV8865_read_cmos_sensor_8(0x3809),i);
	      usleep(100);
	    }
	 num = sizeof(MipiCameraReg)/sizeof(MipiCameraReg[0]);
     for(i=0;i<num;i++){
 4021768:	0081dd04 	movi	r2,1908
 402176c:	84000184 	addi	r16,r16,6
 4021770:	88bfe21e 	bne	r17,r2,40216fc <__alt_data_end+0xfffe16fc>
 4021774:	003fe906 	br	402171c <__alt_data_end+0xfffe171c>

04021778 <QUEUE_New>:
#include "queue.h"




QUEUE_STRUCT* QUEUE_New(int nQueueNum){
 4021778:	defffc04 	addi	sp,sp,-16
 402177c:	dc000015 	stw	r16,0(sp)
    int nSize;
    QUEUE_STRUCT *pQueue;
    nSize = sizeof(QUEUE_STRUCT)+nQueueNum*sizeof(alt_u32);
 4021780:	24000144 	addi	r16,r4,5
 4021784:	8421883a 	add	r16,r16,r16
 4021788:	8421883a 	add	r16,r16,r16
#include "queue.h"




QUEUE_STRUCT* QUEUE_New(int nQueueNum){
 402178c:	dc800215 	stw	r18,8(sp)
 4021790:	2025883a 	mov	r18,r4
    int nSize;
    QUEUE_STRUCT *pQueue;
    nSize = sizeof(QUEUE_STRUCT)+nQueueNum*sizeof(alt_u32);
    pQueue = (QUEUE_STRUCT *)malloc(nSize);
 4021794:	8009883a 	mov	r4,r16
#include "queue.h"




QUEUE_STRUCT* QUEUE_New(int nQueueNum){
 4021798:	dfc00315 	stw	ra,12(sp)
 402179c:	dc400115 	stw	r17,4(sp)
    int nSize;
    QUEUE_STRUCT *pQueue;
    nSize = sizeof(QUEUE_STRUCT)+nQueueNum*sizeof(alt_u32);
    pQueue = (QUEUE_STRUCT *)malloc(nSize);
 40217a0:	4021ab00 	call	4021ab0 <malloc>
    memset((void *)pQueue, 0, nSize);
 40217a4:	800d883a 	mov	r6,r16
 40217a8:	000b883a 	mov	r5,zero
 40217ac:	1009883a 	mov	r4,r2

QUEUE_STRUCT* QUEUE_New(int nQueueNum){
    int nSize;
    QUEUE_STRUCT *pQueue;
    nSize = sizeof(QUEUE_STRUCT)+nQueueNum*sizeof(alt_u32);
    pQueue = (QUEUE_STRUCT *)malloc(nSize);
 40217b0:	1023883a 	mov	r17,r2
    memset((void *)pQueue, 0, nSize);
 40217b4:	4021ad80 	call	4021ad8 <memset>
    pQueue->num = nQueueNum;
    return pQueue;
}
 40217b8:	8805883a 	mov	r2,r17
    int nSize;
    QUEUE_STRUCT *pQueue;
    nSize = sizeof(QUEUE_STRUCT)+nQueueNum*sizeof(alt_u32);
    pQueue = (QUEUE_STRUCT *)malloc(nSize);
    memset((void *)pQueue, 0, nSize);
    pQueue->num = nQueueNum;
 40217bc:	8c800015 	stw	r18,0(r17)
    return pQueue;
}
 40217c0:	dfc00317 	ldw	ra,12(sp)
 40217c4:	dc800217 	ldw	r18,8(sp)
 40217c8:	dc400117 	ldw	r17,4(sp)
 40217cc:	dc000017 	ldw	r16,0(sp)
 40217d0:	dec00404 	addi	sp,sp,16
 40217d4:	f800283a 	ret

040217d8 <QUEUE_Delete>:

void QUEUE_Delete(QUEUE_STRUCT *pQueue){
    free(pQueue);
 40217d8:	4021ac41 	jmpi	4021ac4 <free>

040217dc <QUEUE_IsEmpty>:
}

bool QUEUE_IsEmpty(QUEUE_STRUCT *pQueue){
 40217dc:	20c00117 	ldw	r3,4(r4)
 40217e0:	20800217 	ldw	r2,8(r4)
    if (pQueue->front == pQueue->rear)
        return TRUE;
    return FALSE;
}
 40217e4:	1885003a 	cmpeq	r2,r3,r2
 40217e8:	f800283a 	ret

040217ec <QUEUE_IsFull>:

bool QUEUE_IsFull(QUEUE_STRUCT *pQueue){
 40217ec:	defffe04 	addi	sp,sp,-8
 40217f0:	dc000015 	stw	r16,0(sp)
 40217f4:	2021883a 	mov	r16,r4
 40217f8:	21000117 	ldw	r4,4(r4)
 40217fc:	81400017 	ldw	r5,0(r16)
 4021800:	dfc00115 	stw	ra,4(sp)
 4021804:	21000044 	addi	r4,r4,1
 4021808:	4021a580 	call	4021a58 <__umodsi3>
 402180c:	80c00217 	ldw	r3,8(r16)
    if (((pQueue->front+1)%pQueue->num) == pQueue->rear)
        return TRUE;
    return FALSE;
}
 4021810:	10c5003a 	cmpeq	r2,r2,r3
 4021814:	dfc00117 	ldw	ra,4(sp)
 4021818:	dc000017 	ldw	r16,0(sp)
 402181c:	dec00204 	addi	sp,sp,8
 4021820:	f800283a 	ret

04021824 <QUEUE_Push>:

bool QUEUE_Push(QUEUE_STRUCT *pQueue, alt_u32 data32){
 4021824:	defffd04 	addi	sp,sp,-12
 4021828:	dc400115 	stw	r17,4(sp)
 402182c:	dc000015 	stw	r16,0(sp)
 4021830:	dfc00215 	stw	ra,8(sp)
 4021834:	2021883a 	mov	r16,r4
 4021838:	2823883a 	mov	r17,r5
    if (QUEUE_IsFull(pQueue))
 402183c:	40217ec0 	call	40217ec <QUEUE_IsFull>
 4021840:	10000c1e 	bne	r2,zero,4021874 <QUEUE_Push+0x50>
        return FALSE;
    pQueue->data[pQueue->front] = data32;
 4021844:	81000117 	ldw	r4,4(r16)
    pQueue->front = (pQueue->front+1)%pQueue->num;        
 4021848:	81400017 	ldw	r5,0(r16)
}

bool QUEUE_Push(QUEUE_STRUCT *pQueue, alt_u32 data32){
    if (QUEUE_IsFull(pQueue))
        return FALSE;
    pQueue->data[pQueue->front] = data32;
 402184c:	208000c4 	addi	r2,r4,3
 4021850:	1085883a 	add	r2,r2,r2
 4021854:	1085883a 	add	r2,r2,r2
 4021858:	8085883a 	add	r2,r16,r2
 402185c:	14400015 	stw	r17,0(r2)
    pQueue->front = (pQueue->front+1)%pQueue->num;        
 4021860:	21000044 	addi	r4,r4,1
 4021864:	4021a580 	call	4021a58 <__umodsi3>
 4021868:	80800115 	stw	r2,4(r16)
    return TRUE;
 402186c:	00800044 	movi	r2,1
 4021870:	00000106 	br	4021878 <QUEUE_Push+0x54>
    return FALSE;
}

bool QUEUE_Push(QUEUE_STRUCT *pQueue, alt_u32 data32){
    if (QUEUE_IsFull(pQueue))
        return FALSE;
 4021874:	0005883a 	mov	r2,zero
    pQueue->data[pQueue->front] = data32;
    pQueue->front = (pQueue->front+1)%pQueue->num;        
    return TRUE;
}
 4021878:	dfc00217 	ldw	ra,8(sp)
 402187c:	dc400117 	ldw	r17,4(sp)
 4021880:	dc000017 	ldw	r16,0(sp)
 4021884:	dec00304 	addi	sp,sp,12
 4021888:	f800283a 	ret

0402188c <QUEUE_Pop>:
void QUEUE_Delete(QUEUE_STRUCT *pQueue){
    free(pQueue);
}

bool QUEUE_IsEmpty(QUEUE_STRUCT *pQueue){
    if (pQueue->front == pQueue->rear)
 402188c:	20c00217 	ldw	r3,8(r4)
 4021890:	20800117 	ldw	r2,4(r4)
 4021894:	10c0021e 	bne	r2,r3,40218a0 <QUEUE_Pop+0x14>
}

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
 4021898:	0005883a 	mov	r2,zero
    data32 = pQueue->data[pQueue->rear];
    pQueue->rear = (pQueue->rear+1)%pQueue->num;        
    return data32;
}
 402189c:	f800283a 	ret

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
    data32 = pQueue->data[pQueue->rear];
 40218a0:	188000c4 	addi	r2,r3,3
 40218a4:	1085883a 	add	r2,r2,r2
 40218a8:	1085883a 	add	r2,r2,r2
    pQueue->data[pQueue->front] = data32;
    pQueue->front = (pQueue->front+1)%pQueue->num;        
    return TRUE;
}

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
 40218ac:	defffd04 	addi	sp,sp,-12
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
    data32 = pQueue->data[pQueue->rear];
    pQueue->rear = (pQueue->rear+1)%pQueue->num;        
 40218b0:	21400017 	ldw	r5,0(r4)

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
    data32 = pQueue->data[pQueue->rear];
 40218b4:	2085883a 	add	r2,r4,r2
    pQueue->data[pQueue->front] = data32;
    pQueue->front = (pQueue->front+1)%pQueue->num;        
    return TRUE;
}

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
 40218b8:	dc400115 	stw	r17,4(sp)
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
    data32 = pQueue->data[pQueue->rear];
 40218bc:	14400017 	ldw	r17,0(r2)
    pQueue->data[pQueue->front] = data32;
    pQueue->front = (pQueue->front+1)%pQueue->num;        
    return TRUE;
}

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
 40218c0:	dc000015 	stw	r16,0(sp)
 40218c4:	2021883a 	mov	r16,r4
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
    data32 = pQueue->data[pQueue->rear];
    pQueue->rear = (pQueue->rear+1)%pQueue->num;        
 40218c8:	19000044 	addi	r4,r3,1
    pQueue->data[pQueue->front] = data32;
    pQueue->front = (pQueue->front+1)%pQueue->num;        
    return TRUE;
}

alt_u32 QUEUE_Pop(QUEUE_STRUCT *pQueue){
 40218cc:	dfc00215 	stw	ra,8(sp)
    alt_u32 data32;
    if (QUEUE_IsEmpty(pQueue))
        return 0;
    data32 = pQueue->data[pQueue->rear];
    pQueue->rear = (pQueue->rear+1)%pQueue->num;        
 40218d0:	4021a580 	call	4021a58 <__umodsi3>
 40218d4:	80800215 	stw	r2,8(r16)
    return data32;
 40218d8:	8805883a 	mov	r2,r17
}
 40218dc:	dfc00217 	ldw	ra,8(sp)
 40218e0:	dc400117 	ldw	r17,4(sp)
 40218e4:	dc000017 	ldw	r16,0(sp)
 40218e8:	dec00304 	addi	sp,sp,12
 40218ec:	f800283a 	ret

040218f0 <QUEUE_Empty>:

void QUEUE_Empty(QUEUE_STRUCT *pQueue){
    pQueue->front = 0;
 40218f0:	20000115 	stw	zero,4(r4)
    pQueue->rear = 0;
 40218f4:	20000215 	stw	zero,8(r4)
 40218f8:	f800283a 	ret

040218fc <__divsi3>:
 40218fc:	20001b16 	blt	r4,zero,402196c <__divsi3+0x70>
 4021900:	000f883a 	mov	r7,zero
 4021904:	28001616 	blt	r5,zero,4021960 <__divsi3+0x64>
 4021908:	200d883a 	mov	r6,r4
 402190c:	29001a2e 	bgeu	r5,r4,4021978 <__divsi3+0x7c>
 4021910:	00800804 	movi	r2,32
 4021914:	00c00044 	movi	r3,1
 4021918:	00000106 	br	4021920 <__divsi3+0x24>
 402191c:	10000d26 	beq	r2,zero,4021954 <__divsi3+0x58>
 4021920:	294b883a 	add	r5,r5,r5
 4021924:	10bfffc4 	addi	r2,r2,-1
 4021928:	18c7883a 	add	r3,r3,r3
 402192c:	293ffb36 	bltu	r5,r4,402191c <__alt_data_end+0xfffe191c>
 4021930:	0005883a 	mov	r2,zero
 4021934:	18000726 	beq	r3,zero,4021954 <__divsi3+0x58>
 4021938:	0005883a 	mov	r2,zero
 402193c:	31400236 	bltu	r6,r5,4021948 <__divsi3+0x4c>
 4021940:	314dc83a 	sub	r6,r6,r5
 4021944:	10c4b03a 	or	r2,r2,r3
 4021948:	1806d07a 	srli	r3,r3,1
 402194c:	280ad07a 	srli	r5,r5,1
 4021950:	183ffa1e 	bne	r3,zero,402193c <__alt_data_end+0xfffe193c>
 4021954:	38000126 	beq	r7,zero,402195c <__divsi3+0x60>
 4021958:	0085c83a 	sub	r2,zero,r2
 402195c:	f800283a 	ret
 4021960:	014bc83a 	sub	r5,zero,r5
 4021964:	39c0005c 	xori	r7,r7,1
 4021968:	003fe706 	br	4021908 <__alt_data_end+0xfffe1908>
 402196c:	0109c83a 	sub	r4,zero,r4
 4021970:	01c00044 	movi	r7,1
 4021974:	003fe306 	br	4021904 <__alt_data_end+0xfffe1904>
 4021978:	00c00044 	movi	r3,1
 402197c:	003fee06 	br	4021938 <__alt_data_end+0xfffe1938>

04021980 <__modsi3>:
 4021980:	20001716 	blt	r4,zero,40219e0 <__modsi3+0x60>
 4021984:	000f883a 	mov	r7,zero
 4021988:	2005883a 	mov	r2,r4
 402198c:	28001216 	blt	r5,zero,40219d8 <__modsi3+0x58>
 4021990:	2900162e 	bgeu	r5,r4,40219ec <__modsi3+0x6c>
 4021994:	01800804 	movi	r6,32
 4021998:	00c00044 	movi	r3,1
 402199c:	00000106 	br	40219a4 <__modsi3+0x24>
 40219a0:	30000a26 	beq	r6,zero,40219cc <__modsi3+0x4c>
 40219a4:	294b883a 	add	r5,r5,r5
 40219a8:	31bfffc4 	addi	r6,r6,-1
 40219ac:	18c7883a 	add	r3,r3,r3
 40219b0:	293ffb36 	bltu	r5,r4,40219a0 <__alt_data_end+0xfffe19a0>
 40219b4:	18000526 	beq	r3,zero,40219cc <__modsi3+0x4c>
 40219b8:	1806d07a 	srli	r3,r3,1
 40219bc:	11400136 	bltu	r2,r5,40219c4 <__modsi3+0x44>
 40219c0:	1145c83a 	sub	r2,r2,r5
 40219c4:	280ad07a 	srli	r5,r5,1
 40219c8:	183ffb1e 	bne	r3,zero,40219b8 <__alt_data_end+0xfffe19b8>
 40219cc:	38000126 	beq	r7,zero,40219d4 <__modsi3+0x54>
 40219d0:	0085c83a 	sub	r2,zero,r2
 40219d4:	f800283a 	ret
 40219d8:	014bc83a 	sub	r5,zero,r5
 40219dc:	003fec06 	br	4021990 <__alt_data_end+0xfffe1990>
 40219e0:	0109c83a 	sub	r4,zero,r4
 40219e4:	01c00044 	movi	r7,1
 40219e8:	003fe706 	br	4021988 <__alt_data_end+0xfffe1988>
 40219ec:	00c00044 	movi	r3,1
 40219f0:	003ff106 	br	40219b8 <__alt_data_end+0xfffe19b8>

040219f4 <__udivsi3>:
 40219f4:	200d883a 	mov	r6,r4
 40219f8:	2900152e 	bgeu	r5,r4,4021a50 <__udivsi3+0x5c>
 40219fc:	28001416 	blt	r5,zero,4021a50 <__udivsi3+0x5c>
 4021a00:	00800804 	movi	r2,32
 4021a04:	00c00044 	movi	r3,1
 4021a08:	00000206 	br	4021a14 <__udivsi3+0x20>
 4021a0c:	10000e26 	beq	r2,zero,4021a48 <__udivsi3+0x54>
 4021a10:	28000516 	blt	r5,zero,4021a28 <__udivsi3+0x34>
 4021a14:	294b883a 	add	r5,r5,r5
 4021a18:	10bfffc4 	addi	r2,r2,-1
 4021a1c:	18c7883a 	add	r3,r3,r3
 4021a20:	293ffa36 	bltu	r5,r4,4021a0c <__alt_data_end+0xfffe1a0c>
 4021a24:	18000826 	beq	r3,zero,4021a48 <__udivsi3+0x54>
 4021a28:	0005883a 	mov	r2,zero
 4021a2c:	31400236 	bltu	r6,r5,4021a38 <__udivsi3+0x44>
 4021a30:	314dc83a 	sub	r6,r6,r5
 4021a34:	10c4b03a 	or	r2,r2,r3
 4021a38:	1806d07a 	srli	r3,r3,1
 4021a3c:	280ad07a 	srli	r5,r5,1
 4021a40:	183ffa1e 	bne	r3,zero,4021a2c <__alt_data_end+0xfffe1a2c>
 4021a44:	f800283a 	ret
 4021a48:	0005883a 	mov	r2,zero
 4021a4c:	f800283a 	ret
 4021a50:	00c00044 	movi	r3,1
 4021a54:	003ff406 	br	4021a28 <__alt_data_end+0xfffe1a28>

04021a58 <__umodsi3>:
 4021a58:	2005883a 	mov	r2,r4
 4021a5c:	2900122e 	bgeu	r5,r4,4021aa8 <__umodsi3+0x50>
 4021a60:	28001116 	blt	r5,zero,4021aa8 <__umodsi3+0x50>
 4021a64:	01800804 	movi	r6,32
 4021a68:	00c00044 	movi	r3,1
 4021a6c:	00000206 	br	4021a78 <__umodsi3+0x20>
 4021a70:	30000c26 	beq	r6,zero,4021aa4 <__umodsi3+0x4c>
 4021a74:	28000516 	blt	r5,zero,4021a8c <__umodsi3+0x34>
 4021a78:	294b883a 	add	r5,r5,r5
 4021a7c:	31bfffc4 	addi	r6,r6,-1
 4021a80:	18c7883a 	add	r3,r3,r3
 4021a84:	293ffa36 	bltu	r5,r4,4021a70 <__alt_data_end+0xfffe1a70>
 4021a88:	18000626 	beq	r3,zero,4021aa4 <__umodsi3+0x4c>
 4021a8c:	1806d07a 	srli	r3,r3,1
 4021a90:	11400136 	bltu	r2,r5,4021a98 <__umodsi3+0x40>
 4021a94:	1145c83a 	sub	r2,r2,r5
 4021a98:	280ad07a 	srli	r5,r5,1
 4021a9c:	183ffb1e 	bne	r3,zero,4021a8c <__alt_data_end+0xfffe1a8c>
 4021aa0:	f800283a 	ret
 4021aa4:	f800283a 	ret
 4021aa8:	00c00044 	movi	r3,1
 4021aac:	003ff706 	br	4021a8c <__alt_data_end+0xfffe1a8c>

04021ab0 <malloc>:
 4021ab0:	008100b4 	movhi	r2,1026
 4021ab4:	108e6204 	addi	r2,r2,14728
 4021ab8:	200b883a 	mov	r5,r4
 4021abc:	11000017 	ldw	r4,0(r2)
 4021ac0:	4021bdc1 	jmpi	4021bdc <_malloc_r>

04021ac4 <free>:
 4021ac4:	008100b4 	movhi	r2,1026
 4021ac8:	108e6204 	addi	r2,r2,14728
 4021acc:	200b883a 	mov	r5,r4
 4021ad0:	11000017 	ldw	r4,0(r2)
 4021ad4:	4021af81 	jmpi	4021af8 <_free_r>

04021ad8 <memset>:
 4021ad8:	2005883a 	mov	r2,r4
 4021adc:	2007883a 	mov	r3,r4
 4021ae0:	218d883a 	add	r6,r4,r6
 4021ae4:	19800326 	beq	r3,r6,4021af4 <memset+0x1c>
 4021ae8:	19400005 	stb	r5,0(r3)
 4021aec:	18c00044 	addi	r3,r3,1
 4021af0:	003ffc06 	br	4021ae4 <__alt_data_end+0xfffe1ae4>
 4021af4:	f800283a 	ret

04021af8 <_free_r>:
 4021af8:	28003726 	beq	r5,zero,4021bd8 <_free_r+0xe0>
 4021afc:	28ffff17 	ldw	r3,-4(r5)
 4021b00:	28bfff04 	addi	r2,r5,-4
 4021b04:	1800010e 	bge	r3,zero,4021b0c <_free_r+0x14>
 4021b08:	10c5883a 	add	r2,r2,r3
 4021b0c:	014100b4 	movhi	r5,1026
 4021b10:	294ecd04 	addi	r5,r5,15156
 4021b14:	28c00017 	ldw	r3,0(r5)
 4021b18:	280d883a 	mov	r6,r5
 4021b1c:	1800031e 	bne	r3,zero,4021b2c <_free_r+0x34>
 4021b20:	10000115 	stw	zero,4(r2)
 4021b24:	28800015 	stw	r2,0(r5)
 4021b28:	f800283a 	ret
 4021b2c:	10c00c2e 	bgeu	r2,r3,4021b60 <_free_r+0x68>
 4021b30:	11000017 	ldw	r4,0(r2)
 4021b34:	110b883a 	add	r5,r2,r4
 4021b38:	1940041e 	bne	r3,r5,4021b4c <_free_r+0x54>
 4021b3c:	19400017 	ldw	r5,0(r3)
 4021b40:	18c00117 	ldw	r3,4(r3)
 4021b44:	2909883a 	add	r4,r5,r4
 4021b48:	11000015 	stw	r4,0(r2)
 4021b4c:	10c00115 	stw	r3,4(r2)
 4021b50:	30800015 	stw	r2,0(r6)
 4021b54:	f800283a 	ret
 4021b58:	11400336 	bltu	r2,r5,4021b68 <_free_r+0x70>
 4021b5c:	2807883a 	mov	r3,r5
 4021b60:	19400117 	ldw	r5,4(r3)
 4021b64:	283ffc1e 	bne	r5,zero,4021b58 <__alt_data_end+0xfffe1b58>
 4021b68:	19c00017 	ldw	r7,0(r3)
 4021b6c:	19cd883a 	add	r6,r3,r7
 4021b70:	30800a1e 	bne	r6,r2,4021b9c <_free_r+0xa4>
 4021b74:	10800017 	ldw	r2,0(r2)
 4021b78:	3885883a 	add	r2,r7,r2
 4021b7c:	18800015 	stw	r2,0(r3)
 4021b80:	1889883a 	add	r4,r3,r2
 4021b84:	2900141e 	bne	r5,r4,4021bd8 <_free_r+0xe0>
 4021b88:	29000017 	ldw	r4,0(r5)
 4021b8c:	2085883a 	add	r2,r4,r2
 4021b90:	18800015 	stw	r2,0(r3)
 4021b94:	28800117 	ldw	r2,4(r5)
 4021b98:	00000e06 	br	4021bd4 <_free_r+0xdc>
 4021b9c:	1180032e 	bgeu	r2,r6,4021bac <_free_r+0xb4>
 4021ba0:	00800304 	movi	r2,12
 4021ba4:	20800015 	stw	r2,0(r4)
 4021ba8:	f800283a 	ret
 4021bac:	11000017 	ldw	r4,0(r2)
 4021bb0:	110d883a 	add	r6,r2,r4
 4021bb4:	2980061e 	bne	r5,r6,4021bd0 <_free_r+0xd8>
 4021bb8:	29800017 	ldw	r6,0(r5)
 4021bbc:	3109883a 	add	r4,r6,r4
 4021bc0:	11000015 	stw	r4,0(r2)
 4021bc4:	29000117 	ldw	r4,4(r5)
 4021bc8:	11000115 	stw	r4,4(r2)
 4021bcc:	00000106 	br	4021bd4 <_free_r+0xdc>
 4021bd0:	11400115 	stw	r5,4(r2)
 4021bd4:	18800115 	stw	r2,4(r3)
 4021bd8:	f800283a 	ret

04021bdc <_malloc_r>:
 4021bdc:	defffb04 	addi	sp,sp,-20
 4021be0:	00bfff04 	movi	r2,-4
 4021be4:	dc400115 	stw	r17,4(sp)
 4021be8:	2c4000c4 	addi	r17,r5,3
 4021bec:	88a2703a 	and	r17,r17,r2
 4021bf0:	dc800215 	stw	r18,8(sp)
 4021bf4:	dfc00415 	stw	ra,16(sp)
 4021bf8:	dcc00315 	stw	r19,12(sp)
 4021bfc:	dc000015 	stw	r16,0(sp)
 4021c00:	8c400204 	addi	r17,r17,8
 4021c04:	00800304 	movi	r2,12
 4021c08:	2025883a 	mov	r18,r4
 4021c0c:	8880022e 	bgeu	r17,r2,4021c18 <_malloc_r+0x3c>
 4021c10:	1023883a 	mov	r17,r2
 4021c14:	00000506 	br	4021c2c <_malloc_r+0x50>
 4021c18:	8800040e 	bge	r17,zero,4021c2c <_malloc_r+0x50>
 4021c1c:	00800304 	movi	r2,12
 4021c20:	90800015 	stw	r2,0(r18)
 4021c24:	0005883a 	mov	r2,zero
 4021c28:	00003b06 	br	4021d18 <_malloc_r+0x13c>
 4021c2c:	897ffb36 	bltu	r17,r5,4021c1c <__alt_data_end+0xfffe1c1c>
 4021c30:	008100b4 	movhi	r2,1026
 4021c34:	108ecd04 	addi	r2,r2,15156
 4021c38:	10c00017 	ldw	r3,0(r2)
 4021c3c:	1009883a 	mov	r4,r2
 4021c40:	1821883a 	mov	r16,r3
 4021c44:	80000926 	beq	r16,zero,4021c6c <_malloc_r+0x90>
 4021c48:	80800017 	ldw	r2,0(r16)
 4021c4c:	1445c83a 	sub	r2,r2,r17
 4021c50:	10001516 	blt	r2,zero,4021ca8 <_malloc_r+0xcc>
 4021c54:	014002c4 	movi	r5,11
 4021c58:	28800d2e 	bgeu	r5,r2,4021c90 <_malloc_r+0xb4>
 4021c5c:	80800015 	stw	r2,0(r16)
 4021c60:	80a1883a 	add	r16,r16,r2
 4021c64:	84400015 	stw	r17,0(r16)
 4021c68:	8000221e 	bne	r16,zero,4021cf4 <_malloc_r+0x118>
 4021c6c:	040100b4 	movhi	r16,1026
 4021c70:	840ecc04 	addi	r16,r16,15152
 4021c74:	80800017 	ldw	r2,0(r16)
 4021c78:	10000e1e 	bne	r2,zero,4021cb4 <_malloc_r+0xd8>
 4021c7c:	000b883a 	mov	r5,zero
 4021c80:	9009883a 	mov	r4,r18
 4021c84:	4021e740 	call	4021e74 <_sbrk_r>
 4021c88:	80800015 	stw	r2,0(r16)
 4021c8c:	00000906 	br	4021cb4 <_malloc_r+0xd8>
 4021c90:	80800117 	ldw	r2,4(r16)
 4021c94:	1c00021e 	bne	r3,r16,4021ca0 <_malloc_r+0xc4>
 4021c98:	20800015 	stw	r2,0(r4)
 4021c9c:	00001506 	br	4021cf4 <_malloc_r+0x118>
 4021ca0:	18800115 	stw	r2,4(r3)
 4021ca4:	00001306 	br	4021cf4 <_malloc_r+0x118>
 4021ca8:	8007883a 	mov	r3,r16
 4021cac:	84000117 	ldw	r16,4(r16)
 4021cb0:	003fe406 	br	4021c44 <__alt_data_end+0xfffe1c44>
 4021cb4:	880b883a 	mov	r5,r17
 4021cb8:	9009883a 	mov	r4,r18
 4021cbc:	4021e740 	call	4021e74 <_sbrk_r>
 4021cc0:	04ffffc4 	movi	r19,-1
 4021cc4:	14ffd526 	beq	r2,r19,4021c1c <__alt_data_end+0xfffe1c1c>
 4021cc8:	140000c4 	addi	r16,r2,3
 4021ccc:	00ffff04 	movi	r3,-4
 4021cd0:	80e0703a 	and	r16,r16,r3
 4021cd4:	1400021e 	bne	r2,r16,4021ce0 <_malloc_r+0x104>
 4021cd8:	84400015 	stw	r17,0(r16)
 4021cdc:	00000506 	br	4021cf4 <_malloc_r+0x118>
 4021ce0:	808bc83a 	sub	r5,r16,r2
 4021ce4:	9009883a 	mov	r4,r18
 4021ce8:	4021e740 	call	4021e74 <_sbrk_r>
 4021cec:	14fffa1e 	bne	r2,r19,4021cd8 <__alt_data_end+0xfffe1cd8>
 4021cf0:	003fca06 	br	4021c1c <__alt_data_end+0xfffe1c1c>
 4021cf4:	810002c4 	addi	r4,r16,11
 4021cf8:	00bffe04 	movi	r2,-8
 4021cfc:	80c00104 	addi	r3,r16,4
 4021d00:	2084703a 	and	r2,r4,r2
 4021d04:	10c7c83a 	sub	r3,r2,r3
 4021d08:	18000326 	beq	r3,zero,4021d18 <_malloc_r+0x13c>
 4021d0c:	80e1883a 	add	r16,r16,r3
 4021d10:	00c7c83a 	sub	r3,zero,r3
 4021d14:	80c00015 	stw	r3,0(r16)
 4021d18:	dfc00417 	ldw	ra,16(sp)
 4021d1c:	dcc00317 	ldw	r19,12(sp)
 4021d20:	dc800217 	ldw	r18,8(sp)
 4021d24:	dc400117 	ldw	r17,4(sp)
 4021d28:	dc000017 	ldw	r16,0(sp)
 4021d2c:	dec00504 	addi	sp,sp,20
 4021d30:	f800283a 	ret

04021d34 <_printf_r>:
 4021d34:	defffd04 	addi	sp,sp,-12
 4021d38:	dfc00015 	stw	ra,0(sp)
 4021d3c:	d9800115 	stw	r6,4(sp)
 4021d40:	d9c00215 	stw	r7,8(sp)
 4021d44:	20c00217 	ldw	r3,8(r4)
 4021d48:	018100b4 	movhi	r6,1026
 4021d4c:	31892304 	addi	r6,r6,9356
 4021d50:	19800115 	stw	r6,4(r3)
 4021d54:	280d883a 	mov	r6,r5
 4021d58:	21400217 	ldw	r5,8(r4)
 4021d5c:	d9c00104 	addi	r7,sp,4
 4021d60:	4021f4c0 	call	4021f4c <___vfprintf_internal_r>
 4021d64:	dfc00017 	ldw	ra,0(sp)
 4021d68:	dec00304 	addi	sp,sp,12
 4021d6c:	f800283a 	ret

04021d70 <printf>:
 4021d70:	defffc04 	addi	sp,sp,-16
 4021d74:	dfc00015 	stw	ra,0(sp)
 4021d78:	d9400115 	stw	r5,4(sp)
 4021d7c:	d9800215 	stw	r6,8(sp)
 4021d80:	d9c00315 	stw	r7,12(sp)
 4021d84:	008100b4 	movhi	r2,1026
 4021d88:	108e6204 	addi	r2,r2,14728
 4021d8c:	10800017 	ldw	r2,0(r2)
 4021d90:	014100b4 	movhi	r5,1026
 4021d94:	29492304 	addi	r5,r5,9356
 4021d98:	10c00217 	ldw	r3,8(r2)
 4021d9c:	d9800104 	addi	r6,sp,4
 4021da0:	19400115 	stw	r5,4(r3)
 4021da4:	200b883a 	mov	r5,r4
 4021da8:	11000217 	ldw	r4,8(r2)
 4021dac:	40224700 	call	4022470 <__vfprintf_internal>
 4021db0:	dfc00017 	ldw	ra,0(sp)
 4021db4:	dec00404 	addi	sp,sp,16
 4021db8:	f800283a 	ret

04021dbc <_putchar_r>:
 4021dbc:	21800217 	ldw	r6,8(r4)
 4021dc0:	40225981 	jmpi	4022598 <_putc_r>

04021dc4 <putchar>:
 4021dc4:	008100b4 	movhi	r2,1026
 4021dc8:	108e6204 	addi	r2,r2,14728
 4021dcc:	10800017 	ldw	r2,0(r2)
 4021dd0:	200b883a 	mov	r5,r4
 4021dd4:	11800217 	ldw	r6,8(r2)
 4021dd8:	1009883a 	mov	r4,r2
 4021ddc:	40225981 	jmpi	4022598 <_putc_r>

04021de0 <_puts_r>:
 4021de0:	defffd04 	addi	sp,sp,-12
 4021de4:	dc000015 	stw	r16,0(sp)
 4021de8:	2021883a 	mov	r16,r4
 4021dec:	2809883a 	mov	r4,r5
 4021df0:	dfc00215 	stw	ra,8(sp)
 4021df4:	dc400115 	stw	r17,4(sp)
 4021df8:	2823883a 	mov	r17,r5
 4021dfc:	4021ec40 	call	4021ec4 <strlen>
 4021e00:	81400217 	ldw	r5,8(r16)
 4021e04:	010100b4 	movhi	r4,1026
 4021e08:	21092304 	addi	r4,r4,9356
 4021e0c:	29000115 	stw	r4,4(r5)
 4021e10:	100f883a 	mov	r7,r2
 4021e14:	880d883a 	mov	r6,r17
 4021e18:	8009883a 	mov	r4,r16
 4021e1c:	402248c0 	call	402248c <__sfvwrite_small_dev>
 4021e20:	00ffffc4 	movi	r3,-1
 4021e24:	10c00926 	beq	r2,r3,4021e4c <_puts_r+0x6c>
 4021e28:	81400217 	ldw	r5,8(r16)
 4021e2c:	018100b4 	movhi	r6,1026
 4021e30:	01c00044 	movi	r7,1
 4021e34:	28800117 	ldw	r2,4(r5)
 4021e38:	318b7c04 	addi	r6,r6,11760
 4021e3c:	8009883a 	mov	r4,r16
 4021e40:	103ee83a 	callr	r2
 4021e44:	10bfffe0 	cmpeqi	r2,r2,-1
 4021e48:	0085c83a 	sub	r2,zero,r2
 4021e4c:	dfc00217 	ldw	ra,8(sp)
 4021e50:	dc400117 	ldw	r17,4(sp)
 4021e54:	dc000017 	ldw	r16,0(sp)
 4021e58:	dec00304 	addi	sp,sp,12
 4021e5c:	f800283a 	ret

04021e60 <puts>:
 4021e60:	008100b4 	movhi	r2,1026
 4021e64:	108e6204 	addi	r2,r2,14728
 4021e68:	200b883a 	mov	r5,r4
 4021e6c:	11000017 	ldw	r4,0(r2)
 4021e70:	4021de01 	jmpi	4021de0 <_puts_r>

04021e74 <_sbrk_r>:
 4021e74:	defffd04 	addi	sp,sp,-12
 4021e78:	dc000015 	stw	r16,0(sp)
 4021e7c:	040100b4 	movhi	r16,1026
 4021e80:	dc400115 	stw	r17,4(sp)
 4021e84:	840ece04 	addi	r16,r16,15160
 4021e88:	2023883a 	mov	r17,r4
 4021e8c:	2809883a 	mov	r4,r5
 4021e90:	dfc00215 	stw	ra,8(sp)
 4021e94:	80000015 	stw	zero,0(r16)
 4021e98:	40228500 	call	4022850 <sbrk>
 4021e9c:	00ffffc4 	movi	r3,-1
 4021ea0:	10c0031e 	bne	r2,r3,4021eb0 <_sbrk_r+0x3c>
 4021ea4:	80c00017 	ldw	r3,0(r16)
 4021ea8:	18000126 	beq	r3,zero,4021eb0 <_sbrk_r+0x3c>
 4021eac:	88c00015 	stw	r3,0(r17)
 4021eb0:	dfc00217 	ldw	ra,8(sp)
 4021eb4:	dc400117 	ldw	r17,4(sp)
 4021eb8:	dc000017 	ldw	r16,0(sp)
 4021ebc:	dec00304 	addi	sp,sp,12
 4021ec0:	f800283a 	ret

04021ec4 <strlen>:
 4021ec4:	2005883a 	mov	r2,r4
 4021ec8:	10c00007 	ldb	r3,0(r2)
 4021ecc:	18000226 	beq	r3,zero,4021ed8 <strlen+0x14>
 4021ed0:	10800044 	addi	r2,r2,1
 4021ed4:	003ffc06 	br	4021ec8 <__alt_data_end+0xfffe1ec8>
 4021ed8:	1105c83a 	sub	r2,r2,r4
 4021edc:	f800283a 	ret

04021ee0 <print_repeat>:
 4021ee0:	defffb04 	addi	sp,sp,-20
 4021ee4:	dc800315 	stw	r18,12(sp)
 4021ee8:	dc400215 	stw	r17,8(sp)
 4021eec:	dc000115 	stw	r16,4(sp)
 4021ef0:	dfc00415 	stw	ra,16(sp)
 4021ef4:	2025883a 	mov	r18,r4
 4021ef8:	2823883a 	mov	r17,r5
 4021efc:	d9800005 	stb	r6,0(sp)
 4021f00:	3821883a 	mov	r16,r7
 4021f04:	04000a0e 	bge	zero,r16,4021f30 <print_repeat+0x50>
 4021f08:	88800117 	ldw	r2,4(r17)
 4021f0c:	01c00044 	movi	r7,1
 4021f10:	d80d883a 	mov	r6,sp
 4021f14:	880b883a 	mov	r5,r17
 4021f18:	9009883a 	mov	r4,r18
 4021f1c:	103ee83a 	callr	r2
 4021f20:	843fffc4 	addi	r16,r16,-1
 4021f24:	103ff726 	beq	r2,zero,4021f04 <__alt_data_end+0xfffe1f04>
 4021f28:	00bfffc4 	movi	r2,-1
 4021f2c:	00000106 	br	4021f34 <print_repeat+0x54>
 4021f30:	0005883a 	mov	r2,zero
 4021f34:	dfc00417 	ldw	ra,16(sp)
 4021f38:	dc800317 	ldw	r18,12(sp)
 4021f3c:	dc400217 	ldw	r17,8(sp)
 4021f40:	dc000117 	ldw	r16,4(sp)
 4021f44:	dec00504 	addi	sp,sp,20
 4021f48:	f800283a 	ret

04021f4c <___vfprintf_internal_r>:
 4021f4c:	deffe504 	addi	sp,sp,-108
 4021f50:	d8c00804 	addi	r3,sp,32
 4021f54:	df001915 	stw	fp,100(sp)
 4021f58:	ddc01815 	stw	r23,96(sp)
 4021f5c:	dd801715 	stw	r22,92(sp)
 4021f60:	dd401615 	stw	r21,88(sp)
 4021f64:	dd001515 	stw	r20,84(sp)
 4021f68:	dcc01415 	stw	r19,80(sp)
 4021f6c:	dc801315 	stw	r18,76(sp)
 4021f70:	dc401215 	stw	r17,72(sp)
 4021f74:	dc001115 	stw	r16,68(sp)
 4021f78:	dfc01a15 	stw	ra,104(sp)
 4021f7c:	2027883a 	mov	r19,r4
 4021f80:	2839883a 	mov	fp,r5
 4021f84:	382d883a 	mov	r22,r7
 4021f88:	d9800f15 	stw	r6,60(sp)
 4021f8c:	0021883a 	mov	r16,zero
 4021f90:	d8000e15 	stw	zero,56(sp)
 4021f94:	002f883a 	mov	r23,zero
 4021f98:	002b883a 	mov	r21,zero
 4021f9c:	0025883a 	mov	r18,zero
 4021fa0:	0023883a 	mov	r17,zero
 4021fa4:	d8000c15 	stw	zero,48(sp)
 4021fa8:	d8000b15 	stw	zero,44(sp)
 4021fac:	0029883a 	mov	r20,zero
 4021fb0:	d8c00915 	stw	r3,36(sp)
 4021fb4:	d8c00f17 	ldw	r3,60(sp)
 4021fb8:	19000003 	ldbu	r4,0(r3)
 4021fbc:	20803fcc 	andi	r2,r4,255
 4021fc0:	1080201c 	xori	r2,r2,128
 4021fc4:	10bfe004 	addi	r2,r2,-128
 4021fc8:	10011c26 	beq	r2,zero,402243c <___vfprintf_internal_r+0x4f0>
 4021fcc:	00c00044 	movi	r3,1
 4021fd0:	a0c01426 	beq	r20,r3,4022024 <___vfprintf_internal_r+0xd8>
 4021fd4:	1d000216 	blt	r3,r20,4021fe0 <___vfprintf_internal_r+0x94>
 4021fd8:	a0000626 	beq	r20,zero,4021ff4 <___vfprintf_internal_r+0xa8>
 4021fdc:	00011306 	br	402242c <___vfprintf_internal_r+0x4e0>
 4021fe0:	01400084 	movi	r5,2
 4021fe4:	a1401d26 	beq	r20,r5,402205c <___vfprintf_internal_r+0x110>
 4021fe8:	014000c4 	movi	r5,3
 4021fec:	a1402926 	beq	r20,r5,4022094 <___vfprintf_internal_r+0x148>
 4021ff0:	00010e06 	br	402242c <___vfprintf_internal_r+0x4e0>
 4021ff4:	01400944 	movi	r5,37
 4021ff8:	1140fb26 	beq	r2,r5,40223e8 <___vfprintf_internal_r+0x49c>
 4021ffc:	e0800117 	ldw	r2,4(fp)
 4022000:	d9000005 	stb	r4,0(sp)
 4022004:	01c00044 	movi	r7,1
 4022008:	d80d883a 	mov	r6,sp
 402200c:	e00b883a 	mov	r5,fp
 4022010:	9809883a 	mov	r4,r19
 4022014:	103ee83a 	callr	r2
 4022018:	1000d61e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 402201c:	84000044 	addi	r16,r16,1
 4022020:	00010206 	br	402242c <___vfprintf_internal_r+0x4e0>
 4022024:	01400c04 	movi	r5,48
 4022028:	1140f826 	beq	r2,r5,402240c <___vfprintf_internal_r+0x4c0>
 402202c:	01400944 	movi	r5,37
 4022030:	11400a1e 	bne	r2,r5,402205c <___vfprintf_internal_r+0x110>
 4022034:	d8800005 	stb	r2,0(sp)
 4022038:	e0800117 	ldw	r2,4(fp)
 402203c:	a00f883a 	mov	r7,r20
 4022040:	d80d883a 	mov	r6,sp
 4022044:	e00b883a 	mov	r5,fp
 4022048:	9809883a 	mov	r4,r19
 402204c:	103ee83a 	callr	r2
 4022050:	1000c81e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 4022054:	84000044 	addi	r16,r16,1
 4022058:	0000f306 	br	4022428 <___vfprintf_internal_r+0x4dc>
 402205c:	217ff404 	addi	r5,r4,-48
 4022060:	29403fcc 	andi	r5,r5,255
 4022064:	00c00244 	movi	r3,9
 4022068:	19400736 	bltu	r3,r5,4022088 <___vfprintf_internal_r+0x13c>
 402206c:	00bfffc4 	movi	r2,-1
 4022070:	88800226 	beq	r17,r2,402207c <___vfprintf_internal_r+0x130>
 4022074:	8c4002a4 	muli	r17,r17,10
 4022078:	00000106 	br	4022080 <___vfprintf_internal_r+0x134>
 402207c:	0023883a 	mov	r17,zero
 4022080:	2c63883a 	add	r17,r5,r17
 4022084:	0000e206 	br	4022410 <___vfprintf_internal_r+0x4c4>
 4022088:	01400b84 	movi	r5,46
 402208c:	1140e426 	beq	r2,r5,4022420 <___vfprintf_internal_r+0x4d4>
 4022090:	05000084 	movi	r20,2
 4022094:	213ff404 	addi	r4,r4,-48
 4022098:	21003fcc 	andi	r4,r4,255
 402209c:	00c00244 	movi	r3,9
 40220a0:	19000736 	bltu	r3,r4,40220c0 <___vfprintf_internal_r+0x174>
 40220a4:	00bfffc4 	movi	r2,-1
 40220a8:	90800226 	beq	r18,r2,40220b4 <___vfprintf_internal_r+0x168>
 40220ac:	948002a4 	muli	r18,r18,10
 40220b0:	00000106 	br	40220b8 <___vfprintf_internal_r+0x16c>
 40220b4:	0025883a 	mov	r18,zero
 40220b8:	24a5883a 	add	r18,r4,r18
 40220bc:	0000db06 	br	402242c <___vfprintf_internal_r+0x4e0>
 40220c0:	00c01b04 	movi	r3,108
 40220c4:	10c0d426 	beq	r2,r3,4022418 <___vfprintf_internal_r+0x4cc>
 40220c8:	013fffc4 	movi	r4,-1
 40220cc:	91000226 	beq	r18,r4,40220d8 <___vfprintf_internal_r+0x18c>
 40220d0:	d8000b15 	stw	zero,44(sp)
 40220d4:	00000106 	br	40220dc <___vfprintf_internal_r+0x190>
 40220d8:	04800044 	movi	r18,1
 40220dc:	01001a44 	movi	r4,105
 40220e0:	11001626 	beq	r2,r4,402213c <___vfprintf_internal_r+0x1f0>
 40220e4:	20800916 	blt	r4,r2,402210c <___vfprintf_internal_r+0x1c0>
 40220e8:	010018c4 	movi	r4,99
 40220ec:	11008a26 	beq	r2,r4,4022318 <___vfprintf_internal_r+0x3cc>
 40220f0:	01001904 	movi	r4,100
 40220f4:	11001126 	beq	r2,r4,402213c <___vfprintf_internal_r+0x1f0>
 40220f8:	01001604 	movi	r4,88
 40220fc:	1100ca1e 	bne	r2,r4,4022428 <___vfprintf_internal_r+0x4dc>
 4022100:	00c00044 	movi	r3,1
 4022104:	d8c00e15 	stw	r3,56(sp)
 4022108:	00001406 	br	402215c <___vfprintf_internal_r+0x210>
 402210c:	01001cc4 	movi	r4,115
 4022110:	11009a26 	beq	r2,r4,402237c <___vfprintf_internal_r+0x430>
 4022114:	20800416 	blt	r4,r2,4022128 <___vfprintf_internal_r+0x1dc>
 4022118:	01001bc4 	movi	r4,111
 402211c:	1100c21e 	bne	r2,r4,4022428 <___vfprintf_internal_r+0x4dc>
 4022120:	05400204 	movi	r21,8
 4022124:	00000e06 	br	4022160 <___vfprintf_internal_r+0x214>
 4022128:	01001d44 	movi	r4,117
 402212c:	11000c26 	beq	r2,r4,4022160 <___vfprintf_internal_r+0x214>
 4022130:	01001e04 	movi	r4,120
 4022134:	11000926 	beq	r2,r4,402215c <___vfprintf_internal_r+0x210>
 4022138:	0000bb06 	br	4022428 <___vfprintf_internal_r+0x4dc>
 402213c:	b5000104 	addi	r20,r22,4
 4022140:	b8000726 	beq	r23,zero,4022160 <___vfprintf_internal_r+0x214>
 4022144:	dd000d15 	stw	r20,52(sp)
 4022148:	b5800017 	ldw	r22,0(r22)
 402214c:	b000080e 	bge	r22,zero,4022170 <___vfprintf_internal_r+0x224>
 4022150:	05adc83a 	sub	r22,zero,r22
 4022154:	02800044 	movi	r10,1
 4022158:	00000606 	br	4022174 <___vfprintf_internal_r+0x228>
 402215c:	05400404 	movi	r21,16
 4022160:	b0c00104 	addi	r3,r22,4
 4022164:	d8c00d15 	stw	r3,52(sp)
 4022168:	b5800017 	ldw	r22,0(r22)
 402216c:	002f883a 	mov	r23,zero
 4022170:	0015883a 	mov	r10,zero
 4022174:	d829883a 	mov	r20,sp
 4022178:	b0001426 	beq	r22,zero,40221cc <___vfprintf_internal_r+0x280>
 402217c:	b009883a 	mov	r4,r22
 4022180:	a80b883a 	mov	r5,r21
 4022184:	da801015 	stw	r10,64(sp)
 4022188:	40219f40 	call	40219f4 <__udivsi3>
 402218c:	1549383a 	mul	r4,r2,r21
 4022190:	00c00244 	movi	r3,9
 4022194:	da801017 	ldw	r10,64(sp)
 4022198:	b12dc83a 	sub	r22,r22,r4
 402219c:	1d800216 	blt	r3,r22,40221a8 <___vfprintf_internal_r+0x25c>
 40221a0:	b5800c04 	addi	r22,r22,48
 40221a4:	00000506 	br	40221bc <___vfprintf_internal_r+0x270>
 40221a8:	d8c00e17 	ldw	r3,56(sp)
 40221ac:	18000226 	beq	r3,zero,40221b8 <___vfprintf_internal_r+0x26c>
 40221b0:	b5800dc4 	addi	r22,r22,55
 40221b4:	00000106 	br	40221bc <___vfprintf_internal_r+0x270>
 40221b8:	b58015c4 	addi	r22,r22,87
 40221bc:	a5800005 	stb	r22,0(r20)
 40221c0:	a5000044 	addi	r20,r20,1
 40221c4:	102d883a 	mov	r22,r2
 40221c8:	003feb06 	br	4022178 <__alt_data_end+0xfffe2178>
 40221cc:	a6c7c83a 	sub	r3,r20,sp
 40221d0:	d8c00a15 	stw	r3,40(sp)
 40221d4:	90c5c83a 	sub	r2,r18,r3
 40221d8:	00800a0e 	bge	zero,r2,4022204 <___vfprintf_internal_r+0x2b8>
 40221dc:	a085883a 	add	r2,r20,r2
 40221e0:	01400c04 	movi	r5,48
 40221e4:	d8c00917 	ldw	r3,36(sp)
 40221e8:	a009883a 	mov	r4,r20
 40221ec:	a0c0032e 	bgeu	r20,r3,40221fc <___vfprintf_internal_r+0x2b0>
 40221f0:	a5000044 	addi	r20,r20,1
 40221f4:	21400005 	stb	r5,0(r4)
 40221f8:	a0bffa1e 	bne	r20,r2,40221e4 <__alt_data_end+0xfffe21e4>
 40221fc:	a6c7c83a 	sub	r3,r20,sp
 4022200:	d8c00a15 	stw	r3,40(sp)
 4022204:	d8c00a17 	ldw	r3,40(sp)
 4022208:	50d3883a 	add	r9,r10,r3
 402220c:	d8c00b17 	ldw	r3,44(sp)
 4022210:	8a6dc83a 	sub	r22,r17,r9
 4022214:	18001726 	beq	r3,zero,4022274 <___vfprintf_internal_r+0x328>
 4022218:	50000a26 	beq	r10,zero,4022244 <___vfprintf_internal_r+0x2f8>
 402221c:	00800b44 	movi	r2,45
 4022220:	d8800805 	stb	r2,32(sp)
 4022224:	e0800117 	ldw	r2,4(fp)
 4022228:	01c00044 	movi	r7,1
 402222c:	d9800804 	addi	r6,sp,32
 4022230:	e00b883a 	mov	r5,fp
 4022234:	9809883a 	mov	r4,r19
 4022238:	103ee83a 	callr	r2
 402223c:	10004d1e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 4022240:	84000044 	addi	r16,r16,1
 4022244:	0580070e 	bge	zero,r22,4022264 <___vfprintf_internal_r+0x318>
 4022248:	b00f883a 	mov	r7,r22
 402224c:	01800c04 	movi	r6,48
 4022250:	e00b883a 	mov	r5,fp
 4022254:	9809883a 	mov	r4,r19
 4022258:	4021ee00 	call	4021ee0 <print_repeat>
 402225c:	1000451e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 4022260:	85a1883a 	add	r16,r16,r22
 4022264:	d8c00a17 	ldw	r3,40(sp)
 4022268:	a013883a 	mov	r9,r20
 402226c:	1d2dc83a 	sub	r22,r3,r20
 4022270:	00002206 	br	40222fc <___vfprintf_internal_r+0x3b0>
 4022274:	0580090e 	bge	zero,r22,402229c <___vfprintf_internal_r+0x350>
 4022278:	b00f883a 	mov	r7,r22
 402227c:	01800804 	movi	r6,32
 4022280:	e00b883a 	mov	r5,fp
 4022284:	9809883a 	mov	r4,r19
 4022288:	da801015 	stw	r10,64(sp)
 402228c:	4021ee00 	call	4021ee0 <print_repeat>
 4022290:	da801017 	ldw	r10,64(sp)
 4022294:	1000371e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 4022298:	85a1883a 	add	r16,r16,r22
 402229c:	503ff126 	beq	r10,zero,4022264 <__alt_data_end+0xfffe2264>
 40222a0:	00800b44 	movi	r2,45
 40222a4:	d8800805 	stb	r2,32(sp)
 40222a8:	e0800117 	ldw	r2,4(fp)
 40222ac:	01c00044 	movi	r7,1
 40222b0:	d9800804 	addi	r6,sp,32
 40222b4:	e00b883a 	mov	r5,fp
 40222b8:	9809883a 	mov	r4,r19
 40222bc:	103ee83a 	callr	r2
 40222c0:	10002c1e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 40222c4:	84000044 	addi	r16,r16,1
 40222c8:	003fe606 	br	4022264 <__alt_data_end+0xfffe2264>
 40222cc:	4a7fffc4 	addi	r9,r9,-1
 40222d0:	48800003 	ldbu	r2,0(r9)
 40222d4:	01c00044 	movi	r7,1
 40222d8:	d9800804 	addi	r6,sp,32
 40222dc:	d8800805 	stb	r2,32(sp)
 40222e0:	e0800117 	ldw	r2,4(fp)
 40222e4:	e00b883a 	mov	r5,fp
 40222e8:	da401015 	stw	r9,64(sp)
 40222ec:	9809883a 	mov	r4,r19
 40222f0:	103ee83a 	callr	r2
 40222f4:	da401017 	ldw	r9,64(sp)
 40222f8:	10001e1e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 40222fc:	8245c83a 	sub	r2,r16,r9
 4022300:	4d89883a 	add	r4,r9,r22
 4022304:	a085883a 	add	r2,r20,r2
 4022308:	013ff016 	blt	zero,r4,40222cc <__alt_data_end+0xfffe22cc>
 402230c:	1021883a 	mov	r16,r2
 4022310:	dd800d17 	ldw	r22,52(sp)
 4022314:	00004406 	br	4022428 <___vfprintf_internal_r+0x4dc>
 4022318:	00800044 	movi	r2,1
 402231c:	1440080e 	bge	r2,r17,4022340 <___vfprintf_internal_r+0x3f4>
 4022320:	8d3fffc4 	addi	r20,r17,-1
 4022324:	a00f883a 	mov	r7,r20
 4022328:	01800804 	movi	r6,32
 402232c:	e00b883a 	mov	r5,fp
 4022330:	9809883a 	mov	r4,r19
 4022334:	4021ee00 	call	4021ee0 <print_repeat>
 4022338:	10000e1e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 402233c:	8521883a 	add	r16,r16,r20
 4022340:	b0800017 	ldw	r2,0(r22)
 4022344:	01c00044 	movi	r7,1
 4022348:	d80d883a 	mov	r6,sp
 402234c:	d8800005 	stb	r2,0(sp)
 4022350:	e0800117 	ldw	r2,4(fp)
 4022354:	e00b883a 	mov	r5,fp
 4022358:	9809883a 	mov	r4,r19
 402235c:	b5000104 	addi	r20,r22,4
 4022360:	103ee83a 	callr	r2
 4022364:	1000031e 	bne	r2,zero,4022374 <___vfprintf_internal_r+0x428>
 4022368:	84000044 	addi	r16,r16,1
 402236c:	a02d883a 	mov	r22,r20
 4022370:	00002d06 	br	4022428 <___vfprintf_internal_r+0x4dc>
 4022374:	00bfffc4 	movi	r2,-1
 4022378:	00003106 	br	4022440 <___vfprintf_internal_r+0x4f4>
 402237c:	b5000017 	ldw	r20,0(r22)
 4022380:	b0c00104 	addi	r3,r22,4
 4022384:	d8c00a15 	stw	r3,40(sp)
 4022388:	a009883a 	mov	r4,r20
 402238c:	4021ec40 	call	4021ec4 <strlen>
 4022390:	8893c83a 	sub	r9,r17,r2
 4022394:	102d883a 	mov	r22,r2
 4022398:	0240090e 	bge	zero,r9,40223c0 <___vfprintf_internal_r+0x474>
 402239c:	480f883a 	mov	r7,r9
 40223a0:	01800804 	movi	r6,32
 40223a4:	e00b883a 	mov	r5,fp
 40223a8:	9809883a 	mov	r4,r19
 40223ac:	da401015 	stw	r9,64(sp)
 40223b0:	4021ee00 	call	4021ee0 <print_repeat>
 40223b4:	da401017 	ldw	r9,64(sp)
 40223b8:	103fee1e 	bne	r2,zero,4022374 <__alt_data_end+0xfffe2374>
 40223bc:	8261883a 	add	r16,r16,r9
 40223c0:	e0800117 	ldw	r2,4(fp)
 40223c4:	b00f883a 	mov	r7,r22
 40223c8:	a00d883a 	mov	r6,r20
 40223cc:	e00b883a 	mov	r5,fp
 40223d0:	9809883a 	mov	r4,r19
 40223d4:	103ee83a 	callr	r2
 40223d8:	103fe61e 	bne	r2,zero,4022374 <__alt_data_end+0xfffe2374>
 40223dc:	85a1883a 	add	r16,r16,r22
 40223e0:	dd800a17 	ldw	r22,40(sp)
 40223e4:	00001006 	br	4022428 <___vfprintf_internal_r+0x4dc>
 40223e8:	05c00044 	movi	r23,1
 40223ec:	04bfffc4 	movi	r18,-1
 40223f0:	d8000e15 	stw	zero,56(sp)
 40223f4:	05400284 	movi	r21,10
 40223f8:	9023883a 	mov	r17,r18
 40223fc:	d8000c15 	stw	zero,48(sp)
 4022400:	d8000b15 	stw	zero,44(sp)
 4022404:	b829883a 	mov	r20,r23
 4022408:	00000806 	br	402242c <___vfprintf_internal_r+0x4e0>
 402240c:	dd000b15 	stw	r20,44(sp)
 4022410:	05000084 	movi	r20,2
 4022414:	00000506 	br	402242c <___vfprintf_internal_r+0x4e0>
 4022418:	00c00044 	movi	r3,1
 402241c:	d8c00c15 	stw	r3,48(sp)
 4022420:	050000c4 	movi	r20,3
 4022424:	00000106 	br	402242c <___vfprintf_internal_r+0x4e0>
 4022428:	0029883a 	mov	r20,zero
 402242c:	d8c00f17 	ldw	r3,60(sp)
 4022430:	18c00044 	addi	r3,r3,1
 4022434:	d8c00f15 	stw	r3,60(sp)
 4022438:	003ede06 	br	4021fb4 <__alt_data_end+0xfffe1fb4>
 402243c:	8005883a 	mov	r2,r16
 4022440:	dfc01a17 	ldw	ra,104(sp)
 4022444:	df001917 	ldw	fp,100(sp)
 4022448:	ddc01817 	ldw	r23,96(sp)
 402244c:	dd801717 	ldw	r22,92(sp)
 4022450:	dd401617 	ldw	r21,88(sp)
 4022454:	dd001517 	ldw	r20,84(sp)
 4022458:	dcc01417 	ldw	r19,80(sp)
 402245c:	dc801317 	ldw	r18,76(sp)
 4022460:	dc401217 	ldw	r17,72(sp)
 4022464:	dc001117 	ldw	r16,68(sp)
 4022468:	dec01b04 	addi	sp,sp,108
 402246c:	f800283a 	ret

04022470 <__vfprintf_internal>:
 4022470:	008100b4 	movhi	r2,1026
 4022474:	108e6204 	addi	r2,r2,14728
 4022478:	300f883a 	mov	r7,r6
 402247c:	280d883a 	mov	r6,r5
 4022480:	200b883a 	mov	r5,r4
 4022484:	11000017 	ldw	r4,0(r2)
 4022488:	4021f4c1 	jmpi	4021f4c <___vfprintf_internal_r>

0402248c <__sfvwrite_small_dev>:
 402248c:	2880000b 	ldhu	r2,0(r5)
 4022490:	1080020c 	andi	r2,r2,8
 4022494:	10002126 	beq	r2,zero,402251c <__sfvwrite_small_dev+0x90>
 4022498:	2880008f 	ldh	r2,2(r5)
 402249c:	defffa04 	addi	sp,sp,-24
 40224a0:	dc000015 	stw	r16,0(sp)
 40224a4:	dfc00515 	stw	ra,20(sp)
 40224a8:	dd000415 	stw	r20,16(sp)
 40224ac:	dcc00315 	stw	r19,12(sp)
 40224b0:	dc800215 	stw	r18,8(sp)
 40224b4:	dc400115 	stw	r17,4(sp)
 40224b8:	2821883a 	mov	r16,r5
 40224bc:	10001216 	blt	r2,zero,4022508 <__sfvwrite_small_dev+0x7c>
 40224c0:	2027883a 	mov	r19,r4
 40224c4:	3025883a 	mov	r18,r6
 40224c8:	3823883a 	mov	r17,r7
 40224cc:	05010004 	movi	r20,1024
 40224d0:	04400b0e 	bge	zero,r17,4022500 <__sfvwrite_small_dev+0x74>
 40224d4:	880f883a 	mov	r7,r17
 40224d8:	a440010e 	bge	r20,r17,40224e0 <__sfvwrite_small_dev+0x54>
 40224dc:	01c10004 	movi	r7,1024
 40224e0:	8140008f 	ldh	r5,2(r16)
 40224e4:	900d883a 	mov	r6,r18
 40224e8:	9809883a 	mov	r4,r19
 40224ec:	40225f00 	call	40225f0 <_write_r>
 40224f0:	0080050e 	bge	zero,r2,4022508 <__sfvwrite_small_dev+0x7c>
 40224f4:	88a3c83a 	sub	r17,r17,r2
 40224f8:	90a5883a 	add	r18,r18,r2
 40224fc:	003ff406 	br	40224d0 <__alt_data_end+0xfffe24d0>
 4022500:	0005883a 	mov	r2,zero
 4022504:	00000706 	br	4022524 <__sfvwrite_small_dev+0x98>
 4022508:	8080000b 	ldhu	r2,0(r16)
 402250c:	10801014 	ori	r2,r2,64
 4022510:	8080000d 	sth	r2,0(r16)
 4022514:	00bfffc4 	movi	r2,-1
 4022518:	00000206 	br	4022524 <__sfvwrite_small_dev+0x98>
 402251c:	00bfffc4 	movi	r2,-1
 4022520:	f800283a 	ret
 4022524:	dfc00517 	ldw	ra,20(sp)
 4022528:	dd000417 	ldw	r20,16(sp)
 402252c:	dcc00317 	ldw	r19,12(sp)
 4022530:	dc800217 	ldw	r18,8(sp)
 4022534:	dc400117 	ldw	r17,4(sp)
 4022538:	dc000017 	ldw	r16,0(sp)
 402253c:	dec00604 	addi	sp,sp,24
 4022540:	f800283a 	ret

04022544 <putc>:
 4022544:	defffd04 	addi	sp,sp,-12
 4022548:	008100b4 	movhi	r2,1026
 402254c:	dc000115 	stw	r16,4(sp)
 4022550:	dfc00215 	stw	ra,8(sp)
 4022554:	10892304 	addi	r2,r2,9356
 4022558:	28800115 	stw	r2,4(r5)
 402255c:	008100b4 	movhi	r2,1026
 4022560:	108e6204 	addi	r2,r2,14728
 4022564:	d9000005 	stb	r4,0(sp)
 4022568:	2021883a 	mov	r16,r4
 402256c:	11000017 	ldw	r4,0(r2)
 4022570:	01c00044 	movi	r7,1
 4022574:	d80d883a 	mov	r6,sp
 4022578:	402248c0 	call	402248c <__sfvwrite_small_dev>
 402257c:	00ffffc4 	movi	r3,-1
 4022580:	10c00126 	beq	r2,r3,4022588 <putc+0x44>
 4022584:	8005883a 	mov	r2,r16
 4022588:	dfc00217 	ldw	ra,8(sp)
 402258c:	dc000117 	ldw	r16,4(sp)
 4022590:	dec00304 	addi	sp,sp,12
 4022594:	f800283a 	ret

04022598 <_putc_r>:
 4022598:	defffd04 	addi	sp,sp,-12
 402259c:	008100b4 	movhi	r2,1026
 40225a0:	dc000115 	stw	r16,4(sp)
 40225a4:	dfc00215 	stw	ra,8(sp)
 40225a8:	10892304 	addi	r2,r2,9356
 40225ac:	30800115 	stw	r2,4(r6)
 40225b0:	008100b4 	movhi	r2,1026
 40225b4:	108e6204 	addi	r2,r2,14728
 40225b8:	11000017 	ldw	r4,0(r2)
 40225bc:	2821883a 	mov	r16,r5
 40225c0:	01c00044 	movi	r7,1
 40225c4:	300b883a 	mov	r5,r6
 40225c8:	d80d883a 	mov	r6,sp
 40225cc:	dc000005 	stb	r16,0(sp)
 40225d0:	402248c0 	call	402248c <__sfvwrite_small_dev>
 40225d4:	00ffffc4 	movi	r3,-1
 40225d8:	10c00126 	beq	r2,r3,40225e0 <_putc_r+0x48>
 40225dc:	8005883a 	mov	r2,r16
 40225e0:	dfc00217 	ldw	ra,8(sp)
 40225e4:	dc000117 	ldw	r16,4(sp)
 40225e8:	dec00304 	addi	sp,sp,12
 40225ec:	f800283a 	ret

040225f0 <_write_r>:
 40225f0:	defffd04 	addi	sp,sp,-12
 40225f4:	dc000015 	stw	r16,0(sp)
 40225f8:	040100b4 	movhi	r16,1026
 40225fc:	dc400115 	stw	r17,4(sp)
 4022600:	840ece04 	addi	r16,r16,15160
 4022604:	2023883a 	mov	r17,r4
 4022608:	2809883a 	mov	r4,r5
 402260c:	300b883a 	mov	r5,r6
 4022610:	380d883a 	mov	r6,r7
 4022614:	dfc00215 	stw	ra,8(sp)
 4022618:	80000015 	stw	zero,0(r16)
 402261c:	402298c0 	call	402298c <write>
 4022620:	00ffffc4 	movi	r3,-1
 4022624:	10c0031e 	bne	r2,r3,4022634 <_write_r+0x44>
 4022628:	80c00017 	ldw	r3,0(r16)
 402262c:	18000126 	beq	r3,zero,4022634 <_write_r+0x44>
 4022630:	88c00015 	stw	r3,0(r17)
 4022634:	dfc00217 	ldw	ra,8(sp)
 4022638:	dc400117 	ldw	r17,4(sp)
 402263c:	dc000017 	ldw	r16,0(sp)
 4022640:	dec00304 	addi	sp,sp,12
 4022644:	f800283a 	ret

04022648 <fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 4022648:	defffd04 	addi	sp,sp,-12
 402264c:	dfc00015 	stw	ra,0(sp)
 4022650:	d9800115 	stw	r6,4(sp)
 4022654:	d9c00215 	stw	r7,8(sp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4022658:	20001e16 	blt	r4,zero,40226d4 <fcntl+0x8c>
 402265c:	21000324 	muli	r4,r4,12
 4022660:	008100b4 	movhi	r2,1026
 4022664:	108e4804 	addi	r2,r2,14624
 4022668:	2089883a 	add	r4,r4,r2
  
  if (fd)
 402266c:	20001926 	beq	r4,zero,40226d4 <fcntl+0x8c>
  {
    switch (cmd)
 4022670:	008000c4 	movi	r2,3
 4022674:	28800b26 	beq	r5,r2,40226a4 <fcntl+0x5c>
 4022678:	00800104 	movi	r2,4
 402267c:	28800e1e 	bne	r5,r2,40226b8 <fcntl+0x70>
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
    case F_SETFL:
      va_start(argp, cmd);
      flags = va_arg(argp, long);
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 4022680:	21000204 	addi	r4,r4,8
 4022684:	20c00017 	ldw	r3,0(r4)
 4022688:	00affdc4 	movi	r2,-16393
 402268c:	3190020c 	andi	r6,r6,16392
 4022690:	1884703a 	and	r2,r3,r2
 4022694:	118cb03a 	or	r6,r2,r6
 4022698:	21800015 	stw	r6,0(r4)
      va_end(argp);
      return 0;
 402269c:	0005883a 	mov	r2,zero
 40226a0:	00001406 	br	40226f4 <fcntl+0xac>
  if (fd)
  {
    switch (cmd)
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 40226a4:	20c00217 	ldw	r3,8(r4)
 40226a8:	00900034 	movhi	r2,16384
 40226ac:	10bfffc4 	addi	r2,r2,-1
 40226b0:	1884703a 	and	r2,r3,r2
 40226b4:	00000f06 	br	40226f4 <fcntl+0xac>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
 40226b8:	d0a00f17 	ldw	r2,-32708(gp)
 40226bc:	10000226 	beq	r2,zero,40226c8 <fcntl+0x80>
 40226c0:	103ee83a 	callr	r2
 40226c4:	00000106 	br	40226cc <fcntl+0x84>
 40226c8:	d0a07004 	addi	r2,gp,-32320
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
      va_end(argp);
      return 0;
    default:
      ALT_ERRNO = EINVAL;
 40226cc:	00c00584 	movi	r3,22
 40226d0:	00000606 	br	40226ec <fcntl+0xa4>
 40226d4:	d0a00f17 	ldw	r2,-32708(gp)
 40226d8:	10000226 	beq	r2,zero,40226e4 <fcntl+0x9c>
 40226dc:	103ee83a 	callr	r2
 40226e0:	00000106 	br	40226e8 <fcntl+0xa0>
 40226e4:	d0a07004 	addi	r2,gp,-32320
      return -1;
    }
  }

  ALT_ERRNO = EBADFD;
 40226e8:	00c01444 	movi	r3,81
 40226ec:	10c00015 	stw	r3,0(r2)
  return -1;
 40226f0:	00bfffc4 	movi	r2,-1
}
 40226f4:	dfc00017 	ldw	ra,0(sp)
 40226f8:	dec00304 	addi	sp,sp,12
 40226fc:	f800283a 	ret

04022700 <alt_getchar>:
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
 4022700:	008100b4 	movhi	r2,1026
 4022704:	108e4804 	addi	r2,r2,14624
 4022708:	11c00217 	ldw	r7,8(r2)
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
 402270c:	defffe04 	addi	sp,sp,-8
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
 4022710:	010100b4 	movhi	r4,1026
 4022714:	01800044 	movi	r6,1
 4022718:	d80b883a 	mov	r5,sp
 402271c:	210e6704 	addi	r4,r4,14748
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
 4022720:	dfc00115 	stw	ra,4(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
 4022724:	4022a100 	call	4022a10 <altera_avalon_jtag_uart_read>
 4022728:	0080020e 	bge	zero,r2,4022734 <alt_getchar+0x34>
        return -1;
    }
    return c;
 402272c:	d8800007 	ldb	r2,0(sp)
 4022730:	00000106 	br	4022738 <alt_getchar+0x38>
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
        return -1;
 4022734:	00bfffc4 	movi	r2,-1
    return c;
#else
    return getchar();
#endif
#endif
}
 4022738:	dfc00117 	ldw	ra,4(sp)
 402273c:	dec00204 	addi	sp,sp,8
 4022740:	f800283a 	ret

04022744 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 4022744:	deffff04 	addi	sp,sp,-4
 4022748:	010100b4 	movhi	r4,1026
 402274c:	014100b4 	movhi	r5,1026
 4022750:	dfc00015 	stw	ra,0(sp)
 4022754:	210e1004 	addi	r4,r4,14400
 4022758:	294e6e04 	addi	r5,r5,14776

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 402275c:	2140061e 	bne	r4,r5,4022778 <alt_load+0x34>
 4022760:	010100b4 	movhi	r4,1026
 4022764:	014100b4 	movhi	r5,1026
 4022768:	21000804 	addi	r4,r4,32
 402276c:	29400804 	addi	r5,r5,32
 4022770:	2140121e 	bne	r4,r5,40227bc <alt_load+0x78>
 4022774:	00000b06 	br	40227a4 <alt_load+0x60>
 4022778:	00c100b4 	movhi	r3,1026
 402277c:	18ce6e04 	addi	r3,r3,14776
 4022780:	1907c83a 	sub	r3,r3,r4
 4022784:	0005883a 	mov	r2,zero
  {
    while( to != end )
 4022788:	10fff526 	beq	r2,r3,4022760 <__alt_data_end+0xfffe2760>
    {
      *to++ = *from++;
 402278c:	114f883a 	add	r7,r2,r5
 4022790:	39c00017 	ldw	r7,0(r7)
 4022794:	110d883a 	add	r6,r2,r4
 4022798:	10800104 	addi	r2,r2,4
 402279c:	31c00015 	stw	r7,0(r6)
 40227a0:	003ff906 	br	4022788 <__alt_data_end+0xfffe2788>
 40227a4:	010100b4 	movhi	r4,1026
 40227a8:	014100b4 	movhi	r5,1026
 40227ac:	210ae104 	addi	r4,r4,11140
 40227b0:	294ae104 	addi	r5,r5,11140

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 40227b4:	2140101e 	bne	r4,r5,40227f8 <alt_load+0xb4>
 40227b8:	00000b06 	br	40227e8 <alt_load+0xa4>
 40227bc:	00c100b4 	movhi	r3,1026
 40227c0:	18c00804 	addi	r3,r3,32
 40227c4:	1907c83a 	sub	r3,r3,r4
 40227c8:	0005883a 	mov	r2,zero
  {
    while( to != end )
 40227cc:	10fff526 	beq	r2,r3,40227a4 <__alt_data_end+0xfffe27a4>
    {
      *to++ = *from++;
 40227d0:	114f883a 	add	r7,r2,r5
 40227d4:	39c00017 	ldw	r7,0(r7)
 40227d8:	110d883a 	add	r6,r2,r4
 40227dc:	10800104 	addi	r2,r2,4
 40227e0:	31c00015 	stw	r7,0(r6)
 40227e4:	003ff906 	br	40227cc <__alt_data_end+0xfffe27cc>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 40227e8:	4022b180 	call	4022b18 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 40227ec:	dfc00017 	ldw	ra,0(sp)
 40227f0:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 40227f4:	4022b381 	jmpi	4022b38 <alt_icache_flush_all>
 40227f8:	00c100b4 	movhi	r3,1026
 40227fc:	18ce1004 	addi	r3,r3,14400
 4022800:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 4022804:	0005883a 	mov	r2,zero
  {
    while( to != end )
 4022808:	18bff726 	beq	r3,r2,40227e8 <__alt_data_end+0xfffe27e8>
    {
      *to++ = *from++;
 402280c:	114f883a 	add	r7,r2,r5
 4022810:	39c00017 	ldw	r7,0(r7)
 4022814:	110d883a 	add	r6,r2,r4
 4022818:	10800104 	addi	r2,r2,4
 402281c:	31c00015 	stw	r7,0(r6)
 4022820:	003ff906 	br	4022808 <__alt_data_end+0xfffe2808>

04022824 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4022824:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4022828:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 402282c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4022830:	40229ec0 	call	40229ec <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 4022834:	4022a0c0 	call	4022a0c <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 4022838:	d1a07117 	ldw	r6,-32316(gp)
 402283c:	d1607217 	ldw	r5,-32312(gp)
 4022840:	d1207317 	ldw	r4,-32308(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 4022844:	dfc00017 	ldw	ra,0(sp)
 4022848:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 402284c:	4020dfc1 	jmpi	4020dfc <main>

04022850 <sbrk>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4022850:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4022854:	00bfff84 	movi	r2,-2
 4022858:	2884703a 	and	r2,r5,r2
 402285c:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 4022860:	d0a00517 	ldw	r2,-32748(gp)
 4022864:	00ffff04 	movi	r3,-4
 4022868:	108000c4 	addi	r2,r2,3
 402286c:	10c4703a 	and	r2,r2,r3
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 4022870:	00c10134 	movhi	r3,1028
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 4022874:	d0a00515 	stw	r2,-32748(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 4022878:	1109883a 	add	r4,r2,r4
 402287c:	18c00004 	addi	r3,r3,0
 4022880:	1900032e 	bgeu	r3,r4,4022890 <sbrk+0x40>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4022884:	2801703a 	wrctl	status,r5
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 4022888:	00bfffc4 	movi	r2,-1
 402288c:	f800283a 	ret
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
 4022890:	d1200515 	stw	r4,-32748(gp)
 4022894:	2801703a 	wrctl	status,r5
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
 4022898:	f800283a 	ret

0402289c <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402289c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40228a0:	00bfff84 	movi	r2,-2
 40228a4:	1884703a 	and	r2,r3,r2
 40228a8:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 40228ac:	21400117 	ldw	r5,4(r4)
 40228b0:	20800017 	ldw	r2,0(r4)
 40228b4:	11400115 	stw	r5,4(r2)
  entry->previous->next = entry->next;
 40228b8:	21400117 	ldw	r5,4(r4)
 40228bc:	28800015 	stw	r2,0(r5)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 40228c0:	21000115 	stw	r4,4(r4)
  entry->next     = entry;
 40228c4:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 40228c8:	1801703a 	wrctl	status,r3
 40228cc:	f800283a 	ret

040228d0 <alt_tick>:

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 40228d0:	d0a07417 	ldw	r2,-32304(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 40228d4:	defffb04 	addi	sp,sp,-20
 40228d8:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 40228dc:	d4200617 	ldw	r16,-32744(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 40228e0:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 40228e4:	dc800215 	stw	r18,8(sp)
 40228e8:	dc400115 	stw	r17,4(sp)
 40228ec:	dfc00415 	stw	ra,16(sp)
 40228f0:	dcc00315 	stw	r19,12(sp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 40228f4:	d0a07415 	stw	r2,-32304(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 40228f8:	d4600604 	addi	r17,gp,-32744
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
        {
          alarm->rollover = 1;
 40228fc:	04800044 	movi	r18,1

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 4022900:	84401a26 	beq	r16,r17,402296c <alt_tick+0x9c>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 4022904:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
 4022908:	84c00017 	ldw	r19,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 402290c:	10000326 	beq	r2,zero,402291c <alt_tick+0x4c>
 4022910:	d0a07417 	ldw	r2,-32304(gp)
 4022914:	1000011e 	bne	r2,zero,402291c <alt_tick+0x4c>
    {
      alarm->rollover = 0;
 4022918:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 402291c:	d0e07417 	ldw	r3,-32304(gp)
 4022920:	80800217 	ldw	r2,8(r16)
 4022924:	18800f36 	bltu	r3,r2,4022964 <alt_tick+0x94>
 4022928:	80800403 	ldbu	r2,16(r16)
 402292c:	10000d1e 	bne	r2,zero,4022964 <alt_tick+0x94>
    {
      next_callback = alarm->callback (alarm->context);
 4022930:	80800317 	ldw	r2,12(r16)
 4022934:	81000517 	ldw	r4,20(r16)
 4022938:	103ee83a 	callr	r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 402293c:	1000031e 	bne	r2,zero,402294c <alt_tick+0x7c>
      {
        alt_alarm_stop (alarm);
 4022940:	8009883a 	mov	r4,r16
 4022944:	402289c0 	call	402289c <alt_alarm_stop>
 4022948:	00000606 	br	4022964 <alt_tick+0x94>
      }
      else
      {
        alarm->time += next_callback;
 402294c:	80c00217 	ldw	r3,8(r16)
 4022950:	10c5883a 	add	r2,r2,r3
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 4022954:	d0e07417 	ldw	r3,-32304(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
 4022958:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 402295c:	10c0012e 	bgeu	r2,r3,4022964 <alt_tick+0x94>
        {
          alarm->rollover = 1;
 4022960:	84800405 	stb	r18,16(r16)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 4022964:	9821883a 	mov	r16,r19
 4022968:	003fe506 	br	4022900 <__alt_data_end+0xfffe2900>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 402296c:	dfc00417 	ldw	ra,16(sp)
 4022970:	dcc00317 	ldw	r19,12(sp)
 4022974:	dc800217 	ldw	r18,8(sp)
 4022978:	dc400117 	ldw	r17,4(sp)
 402297c:	dc000017 	ldw	r16,0(sp)
 4022980:	dec00504 	addi	sp,sp,20
 4022984:	f800283a 	ret

04022988 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
 4022988:	4022aa01 	jmpi	4022aa0 <alt_busy_sleep>

0402298c <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
 402298c:	00800044 	movi	r2,1
 4022990:	20800226 	beq	r4,r2,402299c <write+0x10>
 4022994:	00800084 	movi	r2,2
 4022998:	2080041e 	bne	r4,r2,40229ac <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
 402299c:	010100b4 	movhi	r4,1026
 40229a0:	000f883a 	mov	r7,zero
 40229a4:	210e6704 	addi	r4,r4,14748
 40229a8:	4022a6c1 	jmpi	4022a6c <altera_avalon_jtag_uart_write>
 40229ac:	d0a00f17 	ldw	r2,-32708(gp)
 40229b0:	10000926 	beq	r2,zero,40229d8 <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 40229b4:	deffff04 	addi	sp,sp,-4
 40229b8:	dfc00015 	stw	ra,0(sp)
 40229bc:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
 40229c0:	00c01444 	movi	r3,81
 40229c4:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
 40229c8:	00bfffc4 	movi	r2,-1
 40229cc:	dfc00017 	ldw	ra,0(sp)
 40229d0:	dec00104 	addi	sp,sp,4
 40229d4:	f800283a 	ret
 40229d8:	d0a07004 	addi	r2,gp,-32320
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
 40229dc:	00c01444 	movi	r3,81
 40229e0:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
 40229e4:	00bfffc4 	movi	r2,-1
 40229e8:	f800283a 	ret

040229ec <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 40229ec:	deffff04 	addi	sp,sp,-4
 40229f0:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2, nios2_gen2);
 40229f4:	4022b440 	call	4022b44 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 40229f8:	00800044 	movi	r2,1
 40229fc:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 4022a00:	dfc00017 	ldw	ra,0(sp)
 4022a04:	dec00104 	addi	sp,sp,4
 4022a08:	f800283a 	ret

04022a0c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 4022a0c:	f800283a 	ret

04022a10 <altera_avalon_jtag_uart_read>:

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  unsigned int base = sp->base;
 4022a10:	21000017 	ldw	r4,0(r4)

  char * ptr = buffer;
  char * end = buffer + space;
 4022a14:	298d883a 	add	r6,r5,r6

  while (ptr < end)
 4022a18:	2805883a 	mov	r2,r5

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
 4022a1c:	3a10000c 	andi	r8,r7,16384
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
 4022a20:	11800b2e 	bgeu	r2,r6,4022a50 <altera_avalon_jtag_uart_read+0x40>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 4022a24:	20c00037 	ldwio	r3,0(r4)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
 4022a28:	1a60000c 	andi	r9,r3,32768
 4022a2c:	48000326 	beq	r9,zero,4022a3c <altera_avalon_jtag_uart_read+0x2c>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 4022a30:	10c00005 	stb	r3,0(r2)
 4022a34:	10800044 	addi	r2,r2,1
 4022a38:	003ff906 	br	4022a20 <__alt_data_end+0xfffe2a20>
    else if (ptr != buffer)
 4022a3c:	11400226 	beq	r2,r5,4022a48 <altera_avalon_jtag_uart_read+0x38>
      break;   
    
  }

  if (ptr != buffer)
    return ptr - buffer;
 4022a40:	1145c83a 	sub	r2,r2,r5
 4022a44:	f800283a 	ret

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
 4022a48:	403ff526 	beq	r8,zero,4022a20 <__alt_data_end+0xfffe2a20>
 4022a4c:	00000106 	br	4022a54 <altera_avalon_jtag_uart_read+0x44>
      break;   
    
  }

  if (ptr != buffer)
 4022a50:	117ffb1e 	bne	r2,r5,4022a40 <__alt_data_end+0xfffe2a40>
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
 4022a54:	39d0000c 	andi	r7,r7,16384
 4022a58:	3800021e 	bne	r7,zero,4022a64 <altera_avalon_jtag_uart_read+0x54>
    return -EWOULDBLOCK;
  else
    return -EIO;
 4022a5c:	00bffec4 	movi	r2,-5
 4022a60:	f800283a 	ret
  }

  if (ptr != buffer)
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
    return -EWOULDBLOCK;
 4022a64:	00bffd44 	movi	r2,-11
  else
    return -EIO;
}
 4022a68:	f800283a 	ret

04022a6c <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
 4022a6c:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 4022a70:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
 4022a74:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 4022a78:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 4022a7c:	2980072e 	bgeu	r5,r6,4022a9c <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 4022a80:	38c00037 	ldwio	r3,0(r7)
 4022a84:	18ffffec 	andhi	r3,r3,65535
 4022a88:	183ffc26 	beq	r3,zero,4022a7c <__alt_data_end+0xfffe2a7c>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
 4022a8c:	28c00007 	ldb	r3,0(r5)
 4022a90:	20c00035 	stwio	r3,0(r4)
 4022a94:	29400044 	addi	r5,r5,1
 4022a98:	003ff806 	br	4022a7c <__alt_data_end+0xfffe2a7c>

  return count;
}
 4022a9c:	f800283a 	ret

04022aa0 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 4022aa0:	01420034 	movhi	r5,2048
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 4022aa4:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 4022aa8:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 4022aac:	dc000015 	stw	r16,0(sp)
 4022ab0:	dfc00115 	stw	ra,4(sp)
 4022ab4:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 4022ab8:	40219f40 	call	40219f4 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 4022abc:	10000e26 	beq	r2,zero,4022af8 <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 4022ac0:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 4022ac4:	013e0034 	movhi	r4,63488
 4022ac8:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 4022acc:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 4022ad0:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 4022ad4:	297fffc4 	addi	r5,r5,-1
 4022ad8:	283ffe1e 	bne	r5,zero,4022ad4 <__alt_data_end+0xfffe2ad4>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 4022adc:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 4022ae0:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 4022ae4:	18bffb16 	blt	r3,r2,4022ad4 <__alt_data_end+0xfffe2ad4>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 4022ae8:	8020913a 	slli	r16,r16,4
 4022aec:	843fffc4 	addi	r16,r16,-1
 4022af0:	803ffe1e 	bne	r16,zero,4022aec <__alt_data_end+0xfffe2aec>
 4022af4:	00000306 	br	4022b04 <alt_busy_sleep+0x64>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 4022af8:	8020913a 	slli	r16,r16,4
 4022afc:	843fffc4 	addi	r16,r16,-1
 4022b00:	043ffe16 	blt	zero,r16,4022afc <__alt_data_end+0xfffe2afc>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
 4022b04:	0005883a 	mov	r2,zero
 4022b08:	dfc00117 	ldw	ra,4(sp)
 4022b0c:	dc000017 	ldw	r16,0(sp)
 4022b10:	dec00204 	addi	sp,sp,8
 4022b14:	f800283a 	ret

04022b18 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 4022b18:	0005883a 	mov	r2,zero
 4022b1c:	00c10004 	movi	r3,1024
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 4022b20:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 4022b24:	10800804 	addi	r2,r2,32
 4022b28:	10fffd1e 	bne	r2,r3,4022b20 <__alt_data_end+0xfffe2b20>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 4022b2c:	f800283a 	ret

04022b30 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
 4022b30:	3005883a 	mov	r2,r6
 4022b34:	f800283a 	ret

04022b38 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 4022b38:	01410004 	movi	r5,1024
 4022b3c:	0009883a 	mov	r4,zero
 4022b40:	4022b4c1 	jmpi	4022b4c <alt_icache_flush>

04022b44 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 4022b44:	000170fa 	wrctl	ienable,zero
 4022b48:	f800283a 	ret

04022b4c <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
 4022b4c:	00810004 	movi	r2,1024
 4022b50:	1140012e 	bgeu	r2,r5,4022b58 <alt_icache_flush+0xc>
 4022b54:	100b883a 	mov	r5,r2
 4022b58:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 4022b5c:	2005883a 	mov	r2,r4
 4022b60:	1140032e 	bgeu	r2,r5,4022b70 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 4022b64:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 4022b68:	10800804 	addi	r2,r2,32
 4022b6c:	003ffc06 	br	4022b60 <__alt_data_end+0xfffe2b60>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 4022b70:	210007cc 	andi	r4,r4,31
 4022b74:	20000126 	beq	r4,zero,4022b7c <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 4022b78:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 4022b7c:	0000203a 	flushp
 4022b80:	f800283a 	ret
